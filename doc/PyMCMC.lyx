#LyX file created by tex2lyx 1.6.5
\lyxformat 264
\begin_document
\begin_header
\textclass jss
\begin_preamble
\usepackage{listings}\usepackage{bm}\usepackage{float}

\floatstyle{ruled}\newfloat{algorithm}{tbp}{loa}\floatname{algorithm}{Algorithm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% declarations for jss.cls %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% almost as usual
\author{C.M.Strickland\\QueenslandUniversity\\ofTechnology\AndR.J.Denham\\Departmentof\\Environmentand\\ResourceManagement\AndC.L.Alston\\QueenslandUniversity\\ofTechnology\AndK.L.Mengersen\\QueenslandUniversity\\ofTechnology}\title{\pkg{PyMCMC}:A\proglang{Python}packageforBayesianestimationusingMarkovchainMonteCarlo}

%% for pretty printing and a nice hypersummary also set:
\Plainauthor{C.M.Strickland,R.J.Denham,C.L.Alston,K.L.Mengersen}\Plaintitle{PyMCMC:APythonpackageforBayesianestimationusingMarkovchainMonteCarlo}%\Shorttitle{A Capitalized Title}
%% an abstract and keywords
\Abstract{

MarkovchainMonteCarlo(MCMC)estimationprovidesasolutiontothecomplexintegrationproblemsthatarefacedintheBayesiananalysisofstatisticalproblems.TheimplementationofMCMCalgorithmsis,however,codeintensiveandtimeconsuming.Wehavedevelopeda\proglang{Python}package,whichiscalled\pkg{PyMCMC},thataidsintheconstructionofMCMCsamplersandhelpstosubstantiallyreducethelikelihoodofcodingerror,aswellasaidintheminimisationofrepetitivecode.\pkg{PyMCMC}containsclassesforGibbs,MetropolisHastings,independentMetropolisHastings,randomwalkMetropolisHastings,orientationalbiasMonteCarloandslicesamplersaswellasspecificmodulesforcommonmodelssuchasamoduleforBayesianregressionanalysis.\pkg{PyMCMC}isstraightforwardtooptimise,takingadvantageofthe\proglang{Python}libraries\pkg{Numpy}and\pkg{Scipy},aswellasbeingreadilyextensiblewith\proglang{C}or\proglang{Fortran}.

}

\Keywords{keywords,comma-separated,notcapitalized,\proglang{Python}}\Plainkeywords{keywords,comma-separated,notcapitalized,Java}


%% publication information
%% NOTE: Typically, this can be left commented and will be filled out by the technical editor
%% \Volume{13}
%% \Issue{9}
%% \Month{September}
%% \Year{2004}
%% \Submitdate{2004-09-29}
%% \Acceptdate{2004-09-29}
%% The address of (at least) one author should be given
%% in the following format:
\Address{C.M.Strickland\\MathematicalSciences\\GPOBox2434\\QueenslandUniversityofTechnology\\Queensland,4001,Australia\\E-mail:\email{christopher.strickland@qut.edu.au}}

%% It is also possible to add a telephone and fax number
%% before the e-mail in the following format:
%% Telephone: +43/1/31336-5053
%% Fax: +43/1/31336-734
%% for those who use Sweave please include the following line (with % symbols):
%% need no \usepackage{Sweave.sty}
%% end of declarations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\end_preamble
\options article
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\end_header

\begin_body

\begin_layout Section

Introduction
\end_layout

\begin_layout Standard

The most common approach currently used in the estimation of Bayesian Models is Markov chain Monte Carlo (MCMC).
\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 is a 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 module that is designed to simplify the construction of Markov chain Monte Carlo (MCMC) samplers, without sacrificing flexibility or performance. 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 has extensive scientific libraries, is easily extensible, has a clean syntax and powerful programming constructs, making it an ideal programming language to build an MCMC library; see 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
citet{Python}
\end_layout

\end_inset

 for further details on the programming language 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

. It contains objects for the Gibbs sampler, Metropolis Hastings (MH), independent MH, random walk MH, orientational bias Monte Carlo (OBMC) as well as the slice sampler. The user can simply piece together the algorithms required and can easily include their own modules, where necessary. Along with the standard algorithms, 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 includes a module for Bayesian regression analysis. This module can be used for the direct analysis of linear models, or as a part of an MCMC scheme, where the conditional posterior has the form of a linear model. It also contains a class that can be used along with Gibbs sampler for Bayesian variable selection.
\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 is designed to be fully flexible, with respect to MCMC design. This is important in practice, as MCMC algorithms usually need to be tailored to the problem of interest in order to ensure good results. Issues such as block size and parameterisation can have a dramatic effect on the convergence of MCMC sampling schemes. For instance, 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
citet{LuiKongWong1994}
\end_layout

\end_inset

 show theoretically that jointly sampling parameters in a Gibbs scheme typically leads to a reduction in correlation in the associated Markov chain in comparison to individually sampling parameters. This is demonstrated in practical applications in 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
citet{CarterKohn1994}
\end_layout

\end_inset

 and 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
citet{KimShephardChib1998}
\end_layout

\end_inset

. Reducing the correlation in the Markov chain enables it to move more freely through the parameter space and as such enables it to escape from local modes in the posterior distribution. Parameterisation can also have a dramatic effect on the convergence of MCMC samplers; see for example 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
citet{GelfandSahuCarlin1995}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
citet{RobersSahu1997}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
citet{PittShepard1999}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
citet{RobertMengersen1999}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
citet{FruwirthSchnatter2004}
\end_layout

\end_inset

 and 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
citet{StricklandMartinForbes2008}
\end_layout

\end_inset

, who show that the performance of the sampling schemes can be improved dramatically with the use of efficient parameterisation.
\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 aims to remove unnecessary repetitive coding and hence reduce the chance of coding error, and importantly, greatly speed up the construction of efficient MCMC samplers. This is achieved by taking advantage of the flexibility of 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

, which allows for the implementation of very general code. Another feature of 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

, which is particularly important, is it is also extremely easy to include modules from compiled languages such as 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

C
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 and 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Fortran
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

. This is important to many practioners who are forced, by the size and complexity of their problems, to write their MCMC programs entirely in compiled languages, such as 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

C/C++
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 and 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Fortran
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 in order to obtain the necessary speed for feasible practical analysis. With 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

, the user can simply compile 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Fortran
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 code using a module called 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

F2py
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
citet{F2PY}
\end_layout

\end_inset

, or inline 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

C
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 using 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Weave
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

, which is a part of 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Scipy
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
citet{NumpyScipy}
\end_layout

\end_inset

, and use the subroutines directly from 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

. 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

F2py
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 can also be used to directly call 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

C
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 routines with the aid of 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Fortran
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 signiture file. This enables the use of use 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 and 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 as a rapid application development environment, without comprimising on performance by writing only very small segments of their own code in a compiled language. It should be mentioned that for most reasonable sized problems 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 is sufficiently fast for practical MCMC analysis without the need for specialised modules.
\end_layout

\begin_layout Standard


\begin_inset Float figure
placement H
wide false
sideways false
status open


\begin_layout Standard

 
\end_layout

\begin_layout Standard
\align center


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
hspace*{-1cm}
\end_layout

\end_inset


\begin_inset Graphics 
	filename flowchart.pdf
	width 18cm

\end_inset

 
\end_layout

\begin_layout Standard


\begin_inset Caption

\begin_layout Standard
Flow chart of 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\begin_inset LatexCommand label
name "fig:Flow-chart-ofPyMCMC"

\end_inset


\end_layout

\end_inset

\end_layout

\end_inset


\end_layout

\begin_layout Standard

Figure 
\begin_inset LatexCommand ref
reference "fig:Flow-chart-ofPyMCMC"

\end_inset

 is a flow chart that depicts the structure of 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

. Essentially, the implementation of an MCMC sampler can be seen to centred around the class 
\emph on
MCMC
\emph default
, which acts as a container for various algorithms that are used in sampling from the conditional posterior distributions that make up the MCMC sampling scheme.
\end_layout

\begin_layout Standard

The structure of the paper is as follows. In Section 
\begin_inset LatexCommand ref
reference "sec:Bayesian-Analysis"

\end_inset

 the algorithms contained in 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 and the user interface are described. This includes the Gibbs sampler, the Metropolis based algorithms and the slice sampler. Section 
\begin_inset LatexCommand ref
reference "sec:Bayesian-Analysis"

\end_inset

 also contains a description of the Bayesian regression module. Section 
\begin_inset LatexCommand ref
reference "sec:Empirical-Illustrations"

\end_inset

 contains three empirical examples that demonstrate how to use 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

. The first example demonstrates how to use the regression module for the Bayesian analysis of the linear model. In particular, the stochastic search variable selection algorithm, see 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
citet{GeorgeMcCulloch1993}
\end_layout

\end_inset

 and
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
citet{MarinRobert2007}
\end_layout

\end_inset

, is used to select a set of `most likely models'. The second example demonstrates how to use 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 to analyse the loglinear model and the third example demonstrates how to use 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 to analyse a linear model with first order autoregressive errors. Section 
\begin_inset LatexCommand ref
reference "sec:Using-PyMCMC-efficiently"

\end_inset

 contains discussion on the efficient implementation of the MCMC algorithms using 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

. Section 
\begin_inset LatexCommand ref
reference "sec:PyMCMC-interacting-with"

\end_inset

 describes how to use 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 interatively with 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

R
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 and Section 
\begin_inset LatexCommand ref
reference "sec:Conclusions"

\end_inset

 concludes.
\end_layout

\begin_layout Section

Bayesian Analysis
\end_layout

\begin_layout Standard


\begin_inset LatexCommand label
name "sec:Bayesian-Analysis"

\end_inset


\end_layout

\begin_layout Standard

Bayesian analysis quantifies information about the unknown parameter vector of interest, 
\begin_inset Formula $\bm{\theta},$
\end_inset

 for a given data set, 
\begin_inset Formula $\bm{y},$
\end_inset

 through the joint posterior probability density function (pdf), 
\begin_inset Formula $p(\bm{\theta}|\bm{y}),$
\end_inset

 which is defined such that 
\begin_inset Formula \begin{equation}
  p(\bm{\theta}|\bm{y})\propto p(\bm{y}|\bm{\theta})\times
  p(\bm{\theta}),\label{eq:joint post}\end{equation}
\end_inset

 where 
\begin_inset Formula $p(\bm{y}|\bm{\theta})$
\end_inset

 denotes the pdf of 
\begin_inset Formula $\bm{y}$
\end_inset

 given 
\begin_inset Formula $\bm{\theta}$
\end_inset

 and 
\begin_inset Formula $p(\bm{\theta})$
\end_inset

 is the prior pdf for 
\begin_inset Formula $\bm{\theta}.$
\end_inset

 The most common approach used for inference about 
\begin_inset Formula $\bm{\theta}$
\end_inset

 is MCMC.
\end_layout

\begin_layout Subsection

Markov chain Monte Carlo Methods and Implementation
\end_layout

\begin_layout Standard

In the following subsections, a brief description of each algorithm and the associated programming interface is included.
\end_layout

\begin_layout Subsubsection

Markov chain Monte Carlo Sampling
\end_layout

\begin_layout Standard

If we partition 
\begin_inset Formula $\bm{\theta}$
\end_inset

 into 
\begin_inset Formula $s$
\end_inset

 blocks, that is 
\begin_inset Formula $\bm{\bm{\theta}}=\left(\bm{\theta}_{1},\bm{\theta}_{2},\ldots,\bm{\theta}_{s}\right)^{T},$
\end_inset

 then the 
\begin_inset Formula $j^{th}$
\end_inset

\InsetSpace \space{}
step for a generic MCMC sampling scheme is given by:
\end_layout

\begin_layout Standard


\begin_inset Float algorithm
placement H
wide false
sideways false
status open


\begin_layout Standard

 
\end_layout

\begin_layout Description


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset


\series medium
1.
\series default

\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 Sample
\series bold
\InsetSpace \space{}

\series default

\begin_inset Formula $\bm{\theta}_{1}^{j}$
\end_inset

 from 
\begin_inset Formula $p\left(\bm{\theta}_{1}|\bm{y,}\bm{\theta}_{2}^{j-1},\bm{\theta}_{3}^{j-1},\ldots,\bm{\theta}_{s}^{j-1}\right),$
\end_inset

 
\end_layout

\begin_layout Description


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset


\series medium
2.
\series default

\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 Sample 
\begin_inset Formula $\bm{\theta}_{2}^{j}$
\end_inset

 from 
\begin_inset Formula $p\left(\bm{\theta}_{2}|\bm{y,}\bm{\theta}_{1}^{j},\bm{\theta}_{3}^{j-1},\bm{\theta}_{4}^{j-1},\ldots,\bm{\theta}_{s}^{j-1}\right),$
\end_inset


\end_layout

\begin_deeper
\begin_layout Description


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset


\begin_inset Formula $\vdots$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 \InsetSpace ~
 
\end_layout

\end_deeper
\begin_layout Description


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset


\series medium
s.
\series default

\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 Sample 
\begin_inset Formula $\bm{\theta}_{s}^{j}$
\end_inset

 from 
\begin_inset Formula $p\left(\bm{\theta}_{s}|\bm{y,}\bm{\theta}_{1}^{j},\bm{\theta}_{2}^{j},\ldots,\bm{\theta}_{s-1}^{j}\right).$
\end_inset

 
\end_layout

\begin_layout Standard


\begin_inset Caption

\begin_layout Standard
Gibbs sampler
\end_layout

\end_inset

\end_layout

\begin_layout Standard


\begin_inset LatexCommand label
name "alg:MCMC"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard

An important special case of Algorithm 
\begin_inset LatexCommand ref
reference "alg:MCMC"

\end_inset

 is the Gibbs sampler, which is an algorithm that is proposed in . Specficially, when each of 
\begin_inset Formula $\bm{\theta}_{1},\bm{\theta}_{2},\dots,\bm{\theta}_{s},$
\end_inset

 is sampled from a closed form then this algorithm corresponds to that of the Gibbs sampler. 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 contains a class that facilitates the implementation of Algorithm 
\begin_inset LatexCommand ref
reference "alg:MCMC"

\end_inset

, in which the user must define functions to sample from each block, ie. a function for each of 
\begin_inset Formula $\bm{\theta}_{i},$
\end_inset

 for 
\begin_inset Formula $i=1,\dots,s.$
\end_inset

 These functions may be defined using the Metropolis based or slice sampling algorithms that are part of 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

. The class is named 
\emph on
MCMC 
\emph default
and the following arguments are required in the initialisation of the class:
\end_layout

\begin_layout Enumerate

nit - the number of iterations. 
\end_layout

\begin_layout Enumerate

burn - the burnin length of the MCMC sampler 
\end_layout

\begin_layout Enumerate

data - a dictionary (
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 data structure) containing any data, functions or objects that the user would like to have access to when defining the functions that are called from the Gibbs sampler. 
\end_layout

\begin_layout Enumerate

blocks - a list (
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 data structure) containing functions that are used to sample from the full conditional posterior distributions of interest. 
\end_layout

\begin_layout Enumerate

**kwargs - optional arguments: 
\end_layout

\begin_deeper
\begin_layout Enumerate

loglike - a tuple containing a function that evaluates the log-likelihood, number of parameters and the name of the dataset. For example: loglike = (loglike, nparam, 'yvec'). If this is defined then the log-likelihood and the BIC will be reported in the standard output. 
\end_layout

\begin_layout Enumerate

transform - a dictionary, where the keys are the names of the parameters and the associated values are functions that transform the iterates stored in the MCMC scheme. This can be useful when the MCMC algorithm is defined under a particular parametersation, but where it is desirable to report the results under a different parameterisation. 
\end_layout

\end_deeper
\begin_layout Standard

Several functions are included as a part of the class: 
\end_layout

\begin_layout Enumerate

sampler() - used to run the MCMC sampler. 
\end_layout

\begin_layout Enumerate

get_mean_cov(listname) - returns the posterior covariance matrix for the parameters named in listname, where listname is a list that contains the parameter names of interest. 
\end_layout

\begin_layout Enumerate

get_parameter(name) - returns the iterates for the named parameter including burnin. 
\end_layout

\begin_layout Enumerate

get_parameter_exburn(name) - returns the iterates for the named parameter excluding the burnin. 
\end_layout

\begin_layout Enumerate

get_mean_var(name) - returns the estimate from the MCMC estimation for the posterior mean and variance for the parameter defined by 'name'. 
\end_layout

\begin_layout Enumerate

set_number_decimals(num) - sets the number of decimal places for the output. 
\end_layout

\begin_layout Enumerate

output(**kwargs) - Used to produce output from the MCMC algorithm. 
\end_layout

\begin_deeper
\begin_layout Enumerate

**kwargs - Optional arguments that control the output. 
\end_layout

\begin_deeper
\begin_layout Enumerate

parameters: A dictionary, list or string specifying the parameters that are going to be presented. 
\end_layout

\begin_layout Enumerate

If a string is passed (eg: parameters = 'beta'), all elements of that parameter are given. 
\end_layout

\begin_layout Enumerate

If a list, (eg: parameters = ['alpha', 'beta']), all elements of each parameter in the list are given. 
\end_layout

\begin_deeper
\begin_layout Enumerate

If a dictionary (eg: parameters = {'alpha':{'range':range(5)}}), then there is the possibility to add an additional argument 'range' that tells the output to only print a subset of the parameters. The above example will print information for alpha[0], alpha[1],..., alpha[4] only. 
\end_layout

\end_deeper
\begin_layout Enumerate

custom - A user defined function that produces custom output. 
\end_layout

\begin_layout Enumerate

filename - A filename to which the output is printed. By default output will be printed to stdout. 
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

plot(blockname, **kwargs) - Create summary plots of the MCMC sampler. By default, a plot of the marginal posterior density, an ACF plot and a trace plot are produced for each parameter in the block. The plotting page is divided into a number of subfigures. By default, the number of columns are approximately equal to the square root of the total number of subfigures divided by the number of different plot types.
\end_layout

\begin_deeper
\begin_layout Enumerate

blockname The name of the parameter, for which summary plots are to be generated. 
\end_layout

\begin_layout Enumerate

**kwargs - an optional dictionary (
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 data structure) containing information to control the summary plots. The available keys are summarised below:
\end_layout

\begin_deeper
\begin_layout Enumerate

elements: a list of integers specifying the elements that will be plotted. For example, if the blockname is 'beta' and 
\begin_inset Formula $\bm{\beta}=(\beta_{0},\beta_{1}\ldots\beta_{n})$
\end_inset

 then you may specify elements as 
\family typewriter
elements = [0,2,5].
\family default
 
\end_layout

\begin_layout Enumerate

plottypes: a list giving the type of plot for each parameter. By default the plots are density, acf and trace. A single string is also acceptable. 
\end_layout

\begin_layout Enumerate

filename: A string providing the name of an output file for the plot. As a plot of a block may be made up of a number of subfigures, the output name will be modified to give a separate filename for each subfigure. For example, if the filename is passed as 
\begin_inset Quotes eld
\end_inset

plot.png
\begin_inset Quotes erd
\end_inset

, this will be interpreted as 
\begin_inset Quotes eld
\end_inset

plot%03d.png
\begin_inset Quotes erd
\end_inset

, and will produce the files plot001.png, plot002.png, etc. The type of file is determined by the extension of the filename, but the output format will also depend on the plotting backend being used. If the filename does not have a suffix, a default format will be chosen based on the graphics backend. Most backends support png, pdf, ps, eps and svg (see the documentation for Matplotlib for further details http://matplotlib.sourceforge.net). 
\end_layout

\begin_layout Enumerate

individual: A Boolean option. If true, then each subplot will be done on an individual page. 
\end_layout

\begin_layout Enumerate

rows: Integer specifying the number of rows of subfigures on a plotting page. 
\end_layout

\begin_layout Enumerate

cols: Integer specifying the number of columns of subfigures on a plotting page. 
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

CODAoutput(**kwargs) - Output the results in a format suitable for reading in with the statistical package Convergence Diagnostic and Output Analysis (CODA). By default, there will be two files created, coda.txt and coda.ind.
\end_layout

\begin_deeper
\begin_layout Enumerate

**kwargs - an optional dictionary controlling the CODA output.
\end_layout

\begin_deeper
\begin_layout Enumerate

filename: A string to provide an alternative filename for the output. If the file has an extension this will form the basis for the data file and the index file will be named by replacing the extension with ind. If no extension is in the filename then two files will be created and named by adding the extensions .txt and .ind to the given filename. 
\end_layout

\begin_layout Enumerate

parameters: a string, a list or a dictionary that specify the items written to file. It can be a string such as `alpha' or it can be a list (eg [`alpha',`beta']) or it can be a dictionary (eg {`alpha':{`range':[0,1,5]}}. If you supply a dictionary the key is the parameter name. It is also permissible to have a range key with a range of elements. If the range isn't supplied it is assumed that the user wants all of the elements. The range parameter may also be specified as, for example, parameters = {`beta':{`range':[0,2,4]}}. 
\end_layout

\begin_layout Enumerate

thin: integer specifying how to thin the output. For examples if thin = 10, then every tenth element will be written to the CODA output. 
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsubsection

Metropolis Hastings
\end_layout

\begin_layout Standard


\begin_inset LatexCommand label
name "sub:Metropolis-Hastings"

\end_inset


\end_layout

\begin_layout Standard

A particularly useful algorithm that is often used as a part of MCMC samplers is the MH algorithm (Algorithm 
\begin_inset LatexCommand ref
reference "alg:MH"

\end_inset

); see for example 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
citet{RobertCassela1999}
\end_layout

\end_inset

. This algorithm is usually required when we cannot easily sample directly from 
\begin_inset Formula $p(\bm{\theta}|\bm{y}),$
\end_inset

 however, we have a candidate density 
\begin_inset Formula $q(\bm{\theta}|\bm{y})=q(\bm{\theta}|\bm{y},\bm{\theta}^{j-1})$
\end_inset

, which in practice is close to 
\begin_inset Formula $p(\bm{\theta}|\bm{y}$
\end_inset

), and is more readily able to be sampled. The MH algorithm at the 
\begin_inset Formula $j^{th}$
\end_inset

 iteration for 
\begin_inset Formula $j=1,2,\dots,M$
\end_inset

 is given by the following steps:
\end_layout

\begin_layout Standard


\begin_inset Float algorithm
placement H
wide false
sideways false
status open


\begin_layout Standard

 
\end_layout

\begin_layout Enumerate

Draw a candidate 
\begin_inset Formula $\bm{\bm{\theta}}^{\ast}$
\end_inset

 from the density 
\begin_inset Formula $q\left(\bm{\bm{\theta}}|\bm{y},\bm{\theta}^{j-1}\right),$
\end_inset

 
\end_layout

\begin_layout Enumerate

Accept 
\begin_inset Formula $\bm{\theta}^{j}=\bm{\theta}^{\ast}$
\end_inset

 with probability equal to 
\begin_inset Formula $\min\left\{ 1,\frac{p\left(\bm{\theta}^{\ast}|\bm{y}\right)}{p\left(\bm{\theta}^{j-1}|\bm{y}\right)}/\frac{q\left(\bm{\theta}^{\ast}|\bm{y},\bm{\theta}^{j-1}\right)}{q\left(\bm{\theta}^{j-1}|\bm{y},\bm{\theta}^{*}\right)}\right\} ,$
\end_inset

 
\end_layout

\begin_layout Enumerate

Otherwise 
\begin_inset Formula $\bm{\theta}^{j}=\bm{\theta}^{j-1}.$
\end_inset

 
\end_layout

\begin_layout Standard


\begin_inset Caption

\begin_layout Standard
Metropolis Hastings
\end_layout

\end_inset

\end_layout

\begin_layout Standard


\begin_inset LatexCommand label
name "alg:MH"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 includes a class for the MH algorithm, which is called 
\emph on
MH
\emph default
. To initialise the class the user needs to define: 
\end_layout

\begin_layout Enumerate

func - user defined function that returns a sample for the parameter of interest. 
\end_layout

\begin_layout Enumerate

actualprob - user defined function that returns the log probability of the parameters of interest evaluated using the target density. 
\end_layout

\begin_layout Enumerate

probcandprev - user defined function that returns the log of 
\begin_inset Formula $q\left(\bm{\theta}^{\ast}|\bm{y},\bm{\theta}^{j-1}\right).$
\end_inset

 
\end_layout

\begin_layout Enumerate

probprevcand - user defined function that returns the log of 
\begin_inset Formula $q\left(\bm{\theta}^{j-1}|\bm{y},\bm{\theta}^{*}\right).$
\end_inset

 
\end_layout

\begin_layout Enumerate

init_theta - Initial value for the parameters of interest. 
\end_layout

\begin_layout Enumerate

name - The name of the parameter of interest. 
\end_layout

\begin_layout Enumerate

**kwargs - Optional arguments:
\end_layout

\begin_deeper
\begin_layout Enumerate

store - `all' (default), stores every iterate for the parameter of interest. This is required for certain calculations.
\end_layout

\begin_deeper
\begin_layout Enumerate

`none', does not store any of the iterates from the parameter of interest. 
\end_layout

\begin_layout Enumerate

fixed_parameter - is used if the user wants to fix the parameter value that is returned. This is used for testing MCMC sampling schemes. This command will override any other functionality. 
\end_layout

\end_deeper
\end_deeper
\begin_layout Paragraph

Independent Metropolis Hastings
\end_layout

\begin_layout Standard

The independent MH algorithm is a special case of the MH algorithm described in Section 
\begin_inset LatexCommand ref
reference "sub:Metropolis-Hastings"

\end_inset

. Specifically, the independent MH algorithm is applicable when we have a candidate density 
\begin_inset Formula $q(\bm{\theta}|\bm{y})=q(\bm{\theta}|\bm{y},\bm{\theta}^{j-1})$
\end_inset

. The independent MH algorithm at the 
\begin_inset Formula $j^{th}$
\end_inset

 iteration for 
\begin_inset Formula $j=1,2,\ldots,M$
\end_inset

 is given by Algorithm 
\begin_inset LatexCommand ref
reference "alg:IMH"

\end_inset

.
\end_layout

\begin_layout Standard


\begin_inset Float algorithm
placement H
wide false
sideways false
status open


\begin_layout Standard

 
\end_layout

\begin_layout Enumerate

Draw a candidate 
\begin_inset Formula $\bm{\bm{\theta}}^{\ast}$
\end_inset

 from the density 
\begin_inset Formula $q\left(\bm{\bm{\theta}}|\bm{y}\right),$
\end_inset

 
\end_layout

\begin_layout Enumerate

Accept 
\begin_inset Formula $\bm{\theta}^{j}=\bm{\theta}^{\ast}$
\end_inset

 with probability equal to 
\begin_inset Formula $\min\left\{ 1,\frac{p\left(\bm{\theta}^{\ast}|\bm{y}\right)}{p\left(\bm{\theta}^{j-1}|\bm{y}\right)}/\frac{q\left(\bm{\theta}^{\ast}|\bm{y}\right)}{q\left(\bm{\theta}^{j-1}|\bm{y}\right)}\right\} ,$
\end_inset

 
\end_layout

\begin_layout Enumerate

Otherwise accept 
\begin_inset Formula $\bm{\theta}^{j}=\bm{\theta}^{j-1}.$
\end_inset

 
\end_layout

\begin_layout Standard


\begin_inset Caption

\begin_layout Standard
Independent MH algorithm
\end_layout

\end_inset

\end_layout

\begin_layout Standard


\begin_inset LatexCommand label
name "alg:IMH"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 contains a class for the independent MH algorithm, named 
\emph on
IndMH
\emph default
. To initialise the class the user needs to define: 
\end_layout

\begin_layout Enumerate

func - a user defined function that returns a sample for the parameter of interest. 
\end_layout

\begin_layout Enumerate

actualprob - a user defined function that returns the log probability of the parameters of interest evaluated using the target density.q 
\end_layout

\begin_layout Enumerate

candpqrob - a user defined function that returns the log probability of the parameters of interest evaluated using the candidate density. 
\end_layout

\begin_layout Enumerate

init_theta - initial value for the parameters of interest. 
\end_layout

\begin_layout Enumerate

name - name of the parameter of interest. 
\end_layout

\begin_layout Enumerate

kwargs - Optional arguments:
\end_layout

\begin_deeper
\begin_layout Enumerate

store - `all' (default), stores every iterate for the parameter of interest. This is required for certain calculations.
\end_layout

\begin_deeper
\begin_layout Enumerate

`none', does not store any of the iterates from the parameter of interest. 
\end_layout

\begin_layout Enumerate

fixed_parameter - is used if the user wants to fix the parameter value that is returned. This is used for testing MCMC sampling schemes. This command will override any other functionality. 
\end_layout

\end_deeper
\end_deeper
\begin_layout Paragraph

Random Walk Metropolis Hastings 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
protect
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
protect
\end_layout

\end_inset

 
\newline
 
\end_layout

\begin_layout Standard

A useful and simple way to construct an MH candidate distribution is via
\begin_inset Formula \begin{equation}
  \bm{\theta}^{\ast}=\bm{\theta}^{j-1}+\bm{\bm{\varepsilon}},\label{random
    walk candidate}\end{equation}
\end_inset

 where 
\begin_inset Formula $\bm{\varepsilon}$
\end_inset

 is a random disturbance vector. If 
\begin_inset Formula $\bm{\varepsilon}$
\end_inset

 has a distribution that is symmetric about zero then the MH algorithm has a specific form that is referred to as the random walk
\series bold
\InsetSpace \space{}

\series default
MH algorithm. In this case, note that the candidate density is both independent of 
\begin_inset Formula $\bm{y}$
\end_inset

 and, due to symmetry, 
\series bold

\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash

\end_layout

\begin_layout Standard


\end_layout

\end_inset


\series default

\begin_inset Formula $q\left(\bm{\theta}^{\ast}|\bm{\theta}^{j-1}\right)=q\left(\bm{\theta}^{j-1}|\bm{\theta}^{\ast}\right)$
\end_inset

. The random walk MH algorithm at the 
\begin_inset Formula $j^{th}$
\end_inset

 iteration for 
\begin_inset Formula $j=1,2,\ldots,M$
\end_inset

 is given
\emph on
\InsetSpace \space{}

\emph default
by Algorithm 
\begin_inset LatexCommand ref
reference "alg:rwmh"

\end_inset

.
\end_layout

\begin_layout Standard


\begin_inset Float algorithm
placement H
wide false
sideways false
status open


\begin_layout Standard

 
\end_layout

\begin_layout Enumerate

Draw a candidate 
\begin_inset Formula $\bm{\theta}^{\ast}$
\end_inset

 from equation (
\begin_inset LatexCommand ref
reference "random walk candidate"

\end_inset

) where the random disturbance 
\begin_inset Formula $\bm{\varepsilon}$
\end_inset

 has a distribution symmetric about zero. 
\end_layout

\begin_layout Enumerate

Accept 
\begin_inset Formula $\bm{\theta}^{j}=\bm{\theta}^{\ast}$
\end_inset

 with probability equal to 
\begin_inset Formula $\min\left\{
      1,\frac{p\left(\bm{\theta}^{\ast}|\bm{y}\right)}{p\left(\bm{\theta}^{j-1}|\bm{y}\right)}\right\}
    $
\end_inset

 
\end_layout

\begin_layout Enumerate

Otherwise accept 
\begin_inset Formula $\bm{\theta}^{j}=\bm{\theta}^{j-1}.$
\end_inset

 
\end_layout

\begin_layout Standard


\begin_inset Caption

\begin_layout Standard
Random Walk MH
\end_layout

\end_inset

\end_layout

\begin_layout Standard


\begin_inset LatexCommand label
name "alg:rwmh"

\end_inset

q 
\end_layout

\end_inset


\end_layout

\begin_layout Standard

A typical choice for the distribution of 
\begin_inset Formula $\bm{\bm{\varepsilon}}$
\end_inset

 is a Normal distribution,
\emph on
\InsetSpace \space{}

\emph default
that is 
\begin_inset Formula $\bm{\varepsilon\sim}i.i.d.$
\end_inset

 
\begin_inset Formula $\bm{N}\left(0,\bm{\Omega}\right)\ $
\end_inset

where the covariance matrix 
\begin_inset Formula $\bm{\Omega}$
\end_inset

 is viewed as a tuning parameter. 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 includes a class for the random walk MH algorithm, named 
\emph on
RWMH
\emph default
. The class 
\emph on
RWMH
\emph default
 is defined assuming 
\begin_inset Formula $\bm{\varepsilon}$
\end_inset

 follows a normal distribution. Note that more general random walk MH algorithms could be constructed using the MH class. To initialise the class the user must specify: 
\end_layout

\begin_layout Enumerate

post - a user defined function for the log of full conditional posterior distribution for the parameters of interest. 
\end_layout

\begin_layout Enumerate

csig - scale parameter for the random walk MH algorithm. 
\end_layout

\begin_layout Enumerate

init_theta - initial value for the parameter of interest 
\end_layout

\begin_layout Enumerate

name - name of the parameter of interest. 
\end_layout

\begin_layout Enumerate

kwargs - optional arguments:
\end_layout

\begin_deeper
\begin_layout Enumerate

store - `all' (default), stores every iterate for the parameter of interest. This is required for certain calculations.
\end_layout

\begin_deeper
\begin_layout Enumerate

`none', does not store any of the iterates from the parameter of interest. 
\end_layout

\end_deeper
\begin_layout Enumerate

fixed_parameter - is used if the user wants to fix the parameter value that is returned. This is used for testing MCMC sampling schemes. This command will override any other functionality. 
\end_layout

\begin_layout Enumerate

adaptive - `GYS', then the adaptive random walk MH algorithm of 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
citet{GarthwaiteYanScisson2010}
\end_layout

\end_inset

 will be used to optimise 
\begin_inset Formula $\bm{\Omega}.$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Subsubsection

Orientational Bias Monte Carlo
\end_layout

\begin_layout Standard

The multiple try Metropolis 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
citet{LuiLiangWong2000}
\end_layout

\end_inset

 generalises the MH algorithm to allow for multiple proposals. The OBMC algorithm is a special case of the multiple try Metropolis that is applicable when he candidate density is symmetric. The OBMC Algorithm at iteration 
\begin_inset Formula $j$
\end_inset

 is as follows:
\end_layout

\begin_layout Standard


\begin_inset Float algorithm
placement H
wide false
sideways false
status open


\begin_layout Standard

 
\end_layout

\begin_layout Enumerate

Draw 
\begin_inset Formula $L$
\end_inset

 candidates 
\begin_inset Formula $\bm{\theta}_{l}^{\ast},$
\end_inset

 
\begin_inset Formula $l=1,2,\ldots,L$
\end_inset

, independently from the densities 
\begin_inset Formula $q\left(\bm{\theta}|\bm{y},\bm{\theta}^{j-1}\right)$
\end_inset

, where 
\begin_inset Formula $q\left(\bm{\theta}|\bm{y},\bm{\theta}^{j-1}\right)$
\end_inset

 is a symmetric function. 
\end_layout

\begin_layout Enumerate

Construct a 
\shape italic
probability mass function (pmf)
\shape default
 by assigning to each
\emph on
\InsetSpace \space{}

\emph default

\begin_inset Formula $\bm{\theta}_{l}^{\ast},$
\end_inset

 a probability proportional to 
\begin_inset Formula $p\left(\bm{\theta}_{l}^{\ast}|\bm{y}\right).$
\end_inset

 
\end_layout

\begin_layout Enumerate

Select 
\begin_inset Formula $\bm{\theta}^{\ast\ast}$
\end_inset

 randomly from this discrete distribution. 
\end_layout

\begin_layout Enumerate

Draw 
\begin_inset Formula $L-1$
\end_inset

 reference points 
\begin_inset Formula $\bm{r}_{l},$
\end_inset

 
\begin_inset Formula $l=1,2,\ldots,L-1$
\end_inset

,
\series bold
\InsetSpace \space{}

\series default
independently from 
\begin_inset Formula $q\left(\bm{\theta}|\bm{y},\bm{\theta}^{\ast\ast}\right)$
\end_inset

 and set 
\begin_inset Formula $\bm{r}_{L}=\bm{\theta}^{j-1}.$
\end_inset

 
\end_layout

\begin_layout Enumerate

Accept 
\begin_inset Formula $\bm{\theta}^{j}=\bm{\theta}^{\ast\ast}$
\end_inset

 with probability equal to 
\begin_inset Formula $\min\left\{
    1,\frac{\sum_{l=1}^{L}p\left(\bm{\theta}_{l}^{\ast}|\bm{y}\right)}{\sum_{l=1}^{L}p\left(\bm{r}_{l}|\bm{y}\right)}\right\}
  $
\end_inset

 
\end_layout

\begin_layout Enumerate

Otherwise accept 
\begin_inset Formula $\bm{\theta}^{j}=\bm{\theta}^{j-1}.$
\end_inset

 
\end_layout

\begin_layout Standard


\begin_inset Caption

\begin_layout Standard
Orientational Bias Monte Carlo
\end_layout

\end_inset

\end_layout

\begin_layout Standard


\begin_inset LatexCommand label
name "alg:obmc"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 implements a special case of the OBMC algorithm, for which the candidate density is multivariate normal, making it a generalisation of the random walk MH algorithm. The class for the OBMC algorithm is named 
\emph on
OBMC
\emph default
. To initialise the class the user must specify: 
\end_layout

\begin_layout Enumerate

post - a user defined function for the log of full conditional posterior distribution for the parameters of interest. 
\end_layout

\begin_layout Enumerate

ntry - number of candidates, 
\begin_inset Formula $L$
\end_inset

. 
\end_layout

\begin_layout Enumerate

csig - a scale parameter for the OBMC algorithm. 
\end_layout

\begin_layout Enumerate

init_theta - initial value for the parameter of interest. 
\end_layout

\begin_layout Enumerate

**kwargs - optional arguments:
\end_layout

\begin_deeper
\begin_layout Enumerate

store - `all' (default), stores every iterate for the parameter of interest. This is required for certain calculations.
\end_layout

\begin_deeper
\begin_layout Enumerate

`none', does not store any of the iterates from the parameter of interest. 
\end_layout

\end_deeper
\begin_layout Enumerate

fixed_parameter - is used if the user wants to fix the parameter value that is returned. This is used for testing MCMC sampling schemes. This command will override any other functionality. 
\end_layout

\end_deeper
\begin_layout Subsubsection

Closed form sampler
\end_layout

\begin_layout Standard

A class is included so that the user can specify a function to sample the parameters of interest when there is a closed form solution. The name of the class is CFsampler. To initialise the class the user must specify: 
\end_layout

\begin_layout Enumerate

func - user defined function that samples from the posterior distribution of interest. 
\end_layout

\begin_layout Enumerate

init_theta - initial value for the unknown parameter of interest. 
\end_layout

\begin_layout Enumerate

name - the name of the parameter of interest 
\end_layout

\begin_layout Enumerate

**kwargs - optional parameters:
\end_layout

\begin_deeper
\begin_layout Enumerate

store - `all' (default), stores every iterate for the parameter of interest. This is required for certain calculations.
\end_layout

\begin_deeper
\begin_layout Enumerate

`none', does not store any of the iterates from the parameter of interest. 
\end_layout

\end_deeper
\begin_layout Enumerate

fixed_parameter - is used if the user wants to fix the parameter value that is returned. This is used for testing MCMC sampling schemes. This command will override any other functionality. 
\end_layout

\end_deeper
\begin_layout Subsubsection

Slice Sampler
\end_layout

\begin_layout Standard

The slice sampler is useful for drawing values from complex densities; see 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
citet{Radford2003}
\end_layout

\end_inset

 for further details. The required distribution must be proportional to one or a multiple of several other functions of the variable of interest;
\end_layout

\begin_layout Standard


\begin_inset Formula $p(\theta)\propto f_{1}(\theta)f_{2}(\theta)\cdots f_{n}(\theta).$
\end_inset


\end_layout

\begin_layout Standard

A set of values from the distribution is obtained by iteratively sampling a new value, 
\begin_inset Formula $\omega,$
\end_inset

 from the vertical 
\begin_inset Quotes eld
\end_inset

slice
\begin_inset Quotes erd
\end_inset

 between 0 and 
\begin_inset Formula $f_{i}(\theta)$
\end_inset

, then sampling a value for the parameter 
\begin_inset Formula $\theta$
\end_inset

 from the horizontal 
\emph on
slice
\emph default
 that consists of the set of possible values of 
\begin_inset Formula $\theta$
\end_inset

, for which the previously sampled 
\begin_inset Formula $\omega\le p(\theta)$
\end_inset

. This leads to the slice sampler algorithm, which can be defined at iteration 
\begin_inset Formula $j$
\end_inset

 using Algorithm 
\begin_inset LatexCommand ref
reference "alg:slicesamp"

\end_inset

.
\end_layout

\begin_layout Standard


\begin_inset Float algorithm
placement H
wide false
sideways false
status open


\begin_layout Standard

 
\end_layout

\begin_layout Enumerate

For 
\begin_inset Formula $i=1,2,\dots,n$
\end_inset

, draw 
\begin_inset Formula $\omega_{i}\sim\mbox{Unif}[0,f_{i}(\theta^{j-1})]$
\end_inset

 
\end_layout

\begin_layout Enumerate

Sample 
\begin_inset Formula $\theta^{j}\sim\mbox{Unif}[A]$
\end_inset

 where 
\begin_inset Formula $A=\left\{ \theta:f_{1}(\theta)\ge\omega_{1}\in f_{2}(\theta)\ge\omega_{2}\in\cdots\in f_{n}(\theta)\ge\omega_{n}\right\} $
\end_inset

 
\end_layout

\begin_layout Standard


\begin_inset Caption

\begin_layout Standard
Slice sampler
\end_layout

\end_inset

\end_layout

\begin_layout Standard


\begin_inset LatexCommand label
name "alg:slicesamp"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard

In cases where the density of interest is not unimodal, determining the exact set 
\begin_inset Formula $A$
\end_inset

 is not necessarily straightforward. The 
\emph on
stepping out
\emph default
 algorithm of 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
citet{Radford2003}
\end_layout

\end_inset

 is used to obtain the set 
\begin_inset Formula $A$
\end_inset

. This algorithm is applied to each of the 
\begin_inset Formula $n$
\end_inset

 slices to obtain the joint maximum and minimum of the slice. This results in a sampling interval that is designed to sample a new 
\begin_inset Formula $\theta^{j}$
\end_inset

 in the neighbourhood of 
\begin_inset Formula $\theta^{j-1}$
\end_inset

 and may include values outside the permissible range of 
\begin_inset Formula $A$
\end_inset

. The user is required to define an estimated typical slice size (
\begin_inset Formula $ss$
\end_inset

), which is the width of set 
\begin_inset Formula $A$
\end_inset

, along with an integer value (
\begin_inset Formula $N$
\end_inset

), which limits the width of any slice to 
\begin_inset Formula $N*ss$
\end_inset

. The stepping out algorithm (
\begin_inset LatexCommand ref
reference "alg:steppingout"

\end_inset

) is:
\end_layout

\begin_layout Standard


\begin_inset Float algorithm
placement H
wide false
sideways false
status open


\begin_layout Standard

 
\end_layout

\begin_layout Enumerate

Initiate lower (LB) and upper (UB) bounds for slice defined by set 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_layout Itemize


\begin_inset Formula $U\sim\mbox{Unif}(0,1)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize


\begin_inset Formula $LB=\theta^{j-1}-ss*U$
\end_inset

 
\end_layout

\begin_layout Itemize


\begin_inset Formula $UB=LB+ss$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate

Sample 
\begin_inset Formula $V\sim\mbox{Unif}(0,1)$
\end_inset

 
\end_layout

\begin_layout Enumerate

Set 
\begin_inset Formula $J=\mbox{Floor}(N*V)$
\end_inset

 
\end_layout

\begin_layout Enumerate

Set 
\begin_inset Formula $Z=(N-1)-J$
\end_inset

 
\end_layout

\begin_layout Enumerate

Repeat while 
\begin_inset Formula $J>0$
\end_inset

 and 
\begin_inset Formula $\omega_{i}<f_{i}(LB)\forall i$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

LB = LB - 
\begin_inset Formula $ss$
\end_inset

 
\end_layout

\begin_layout Itemize


\begin_inset Formula $J=J-1$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate

Repeat while 
\begin_inset Formula $Z>0$
\end_inset

 and 
\begin_inset Formula $\omega_{i}<f_{i}(UB)\forall i$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

UB = UB + ss 
\end_layout

\begin_layout Itemize

Z = Z - 1 
\end_layout

\end_deeper
\begin_layout Enumerate

Sample 
\begin_inset Formula $\theta^{j}\sim\mbox{Unif}(LB,UB)$
\end_inset

 
\end_layout

\begin_layout Standard


\begin_inset Caption

\begin_layout Standard
Stepping out
\end_layout

\end_inset

\end_layout

\begin_layout Standard


\begin_inset LatexCommand label
name "alg:steppingout"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard

The value of 
\begin_inset Formula $\theta^{j}$
\end_inset

 is accepted if it is drawn from a range 
\begin_inset Formula $(LB,UB)\in A$
\end_inset

. If it is outside the allowable range due to the interval 
\begin_inset Formula $(LB,UB)$
\end_inset

 being larger in range then the set 
\begin_inset Formula $A$
\end_inset

 we then invoke a shrinkage technique to resample 
\begin_inset Formula $\theta^{j}$
\end_inset

 and improve the sampling efficiency of future draws, until an acceptable 
\begin_inset Formula $\theta^{j}$
\end_inset

 is drawn. The shrinkage algorithm is implemented as follows, repeating this algorithm until exit conditions are met.
\end_layout

\begin_layout Standard


\begin_inset Float algorithm
placement H
wide false
sideways false
status open


\begin_layout Standard

 
\end_layout

\begin_layout Enumerate


\begin_inset Formula $U\sim\mbox{Unif}(0,1)$
\end_inset

 
\end_layout

\begin_layout Enumerate


\begin_inset Formula $\theta^{j}=LB+U*(UB-LB)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

If 
\begin_inset Formula $\omega_{i}<f_{i}(\omega_{i})\forall i$
\end_inset

, accept 
\begin_inset Formula $\theta^{j}$
\end_inset

 and exit 
\end_layout

\begin_layout Itemize

else if 
\begin_inset Formula $\theta^{j}<\theta^{j-1}$
\end_inset

, set 
\begin_inset Formula $LB=\theta^{j}$
\end_inset

 and return to step 1 
\end_layout

\begin_layout Itemize

else set 
\begin_inset Formula $UB=\theta^{j}$
\end_inset

 and return to step 1 
\end_layout

\end_deeper
\begin_layout Standard


\begin_inset Caption

\begin_layout Standard
Shrinkage
\end_layout

\end_inset

\end_layout

\begin_layout Standard


\begin_inset LatexCommand label
name "alg:shrinkage"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 includes a class for the slice sampler named 
\emph on
SliceSampler. 
\emph default
To initialise the class the user must define: 
\end_layout

\begin_layout Enumerate

func - a 
\begin_inset Formula $k$
\end_inset

 dimensional list containing the set of log functions. 
\end_layout

\begin_layout Enumerate

init_theta - an initial value for 
\begin_inset Formula $\theta$
\end_inset

. 
\end_layout

\begin_layout Enumerate

ssize - a user defined value for the typical slice size. 
\end_layout

\begin_layout Enumerate

sN - an integer limiting slice size to sN*ssize 
\end_layout

\begin_layout Enumerate

**kwargs - optional arguments:
\end_layout

\begin_deeper
\begin_layout Enumerate

store - `all' (default), stores every iterate for the parameter of interest. This is required for certain calculations.
\end_layout

\begin_deeper
\begin_layout Enumerate

`none', does not store any of the iterates from the parameter of interest. 
\end_layout

\begin_layout Enumerate

fixed_parameter - is used if the user wants to fix the parameter value that is returned. This is used for testing MCMC sampling schemes. This command will override any other functionality. 
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection

Normal Linear Bayesian Regression Model
\end_layout

\begin_layout Standard

Many interesting models are partly linear for a subset of the unknown parameters. As such drawing from the full conditional posterior distribution for the associated parameters may be equivalent to sampling the unknown parameters in standard linear regression model. For the standard linear regression model, assume the 
\begin_inset Formula $\left(n\times1\right)$
\end_inset

 observational vector, 
\begin_inset Formula $\bm{y},$
\end_inset

 is generated according to
\begin_inset Formula \begin{equation}
  \bm{y}=\bm{X}\bm{\beta}+\bm{\varepsilon};\,\,\,\bm{\varepsilon}\sim
  N(\bm{0},\sigma^{2}\bm{I}),\label{eq:regression}\end{equation}
\end_inset

 where 
\begin_inset Formula $\bm{X}$
\end_inset

 is an 
\begin_inset Formula $(n\times k)$
\end_inset

 matrix of regressors, 
\begin_inset Formula $\bm{\beta}$
\end_inset

 is a 
\begin_inset Formula $\left(k\times1\right)$
\end_inset

 vector of regression coefficients and 
\begin_inset Formula $\bm{\varepsilon}$
\end_inset

 is a normally distributed random variable with a mean vector 
\begin_inset Formula $\bm{0}$
\end_inset

 and an 
\begin_inset Formula $\left(n\times n\right)$
\end_inset

 covariance matrix, 
\begin_inset Formula $\sigma^{2}\bm{I}.$
\end_inset

 Assuming that both 
\begin_inset Formula $\bm{\beta}$
\end_inset

 and 
\begin_inset Formula $\sigma$
\end_inset

 are unknown then the posterior distribution for (
\begin_inset LatexCommand ref
reference "eq:regression"

\end_inset

) is given by
\begin_inset Formula \begin{equation}
  p(\bm{\beta},\sigma|\bm{y},\bm{X})\propto
  p(\bm{y}|\bm{X},\bm{\beta},\sigma)\times
  p(\bm{\beta},\sigma),\label{eq:post regression}\end{equation}
\end_inset

 where 
\begin_inset Formula \begin{equation}
  p(\bm{y}|\bm{X},\bm{\beta},\sigma)\propto\sigma^{-n}\exp\left\{
    -\frac{1}{2\sigma^{2}}\left(\bm{y}-\bm{X}\bm{\beta}\right)^{T}\left(\bm{y}-\bm{X}\bm{\beta}\right)\right\}
  ,\label{eq:likelihood regression}\end{equation}
\end_inset

 is the joint 
\emph on
pdf 
\emph default
for 
\begin_inset Formula $\bm{y}$
\end_inset

 given 
\begin_inset Formula $\bm{X},$
\end_inset

 
\begin_inset Formula $\bm{\beta}$
\end_inset

 and 
\begin_inset Formula $\sigma,$
\end_inset


\emph on
 
\emph default
and
\emph on
 
\begin_inset Formula $p(\bm{\beta},\sigma)$
\end_inset

 
\emph default
denotes the joint prior 
\emph on
pdf
\emph default
 for 
\begin_inset Formula $\bm{\beta}$
\end_inset

 and 
\begin_inset Formula $\sigma.$
\end_inset


\end_layout

\begin_layout Standard

A class named 
\emph on
BayesRegression 
\emph default
is defined to sample from the posterior distribution in (
\begin_inset LatexCommand ref
reference "eq:post regression"

\end_inset

). One of four alternative priors may be used in the specification of the model. The default choice is Jeffreys' prior. Denoting the full set of unknown parameters as 
\begin_inset Formula $\bm{\theta}=(\bm{\beta}^{T},\sigma)^{T},$
\end_inset

 then Jeffreys' prior is defined such that 
\begin_inset Formula \begin{equation}
  p(\bm{\theta})\propto|I(\bm{\theta})|^{-1/2},\label{eq:Jeffrey's
    Prior}\end{equation}
\end_inset

 where 
\begin_inset Formula $I(\bm{\theta})$
\end_inset

 is the Fisher information matrix for 
\begin_inset Formula $\bm{\theta}.$
\end_inset

 Three alternative informative prior specifications are allowed, namely, the normal-gamma prior, the normal-inverted gamma and Zelner's g-prior. The normal-gamma prior is specified such that
\begin_inset Formula \begin{equation} \bm{\beta}|\kappa\sim
  N(\bm{\underline{\beta}},\underline{\bm{V}}^{-1}),\,\,\,\kappa\sim
  G\left(\frac{\underline{\nu}}{2},\frac{\underline{S}}{2}\right),\label{eq:Normal
    Gamma}\end{equation}
\end_inset

 where 
\begin_inset Formula $\kappa=\sigma^{-2}$
\end_inset

 and 
\begin_inset Formula $\underline{\beta,}$
\end_inset

 
\begin_inset Formula $\underline{\bm{V}},$
\end_inset

 
\begin_inset Formula $\underline{\nu}$
\end_inset

 and 
\begin_inset Formula $\underline{S}$
\end_inset

 are prior hyperparameters, which take user defined values. For the Normal-gamma prior, 
\emph on
BayesRegression 
\emph default
produces estimates for
\emph on
 
\begin_inset Formula $\left(\bm{\kappa,\beta}^{T}\right)^{T}$
\end_inset

 
\emph default
rather than 
\begin_inset Formula $\left(\bm{\sigma,\beta}^{T}\right)$
\end_inset

 . The Normal-inverted gamma prior is specified such that
\begin_inset Formula \begin{equation}
  \bm{\beta}|\sigma^{-2}\sim
  N(\bm{\underline{\beta}},\underline{\bm{V}}^{-1}),\,\,\,\sigma^{-2}\sim
  IG\left(\frac{\underline{\nu}}{2},\frac{\underline{S}}{2}\right),\label{eq:Normal
    Inverted Gamma}\end{equation}
\end_inset

 where 
\begin_inset Formula $\underline{\beta,}$
\end_inset

 
\begin_inset Formula $\underline{\bm{V}},$
\end_inset

 
\begin_inset Formula $\underline{\nu}$
\end_inset

 and 
\begin_inset Formula $\underline{S}$
\end_inset

 are prior hyperparameters, which take values that are set by the user. Zelner's g-prior is specified such that
\begin_inset Formula \begin{equation} \bm{\beta}|\sigma\sim
  N\left(\underline{\bm{\beta}},g\sigma^{2}\left(X^{T}X\right)^{-1}\right),\,\,\,
  p(\sigma)\propto\sigma^{-1},\label{eq:g-prior}\end{equation}
\end_inset


\end_layout

\begin_layout Standard

where 
\begin_inset Formula $\bm{\underline{\beta}}$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 are hyperparameters with values that are specified by the user. To initialise the class 
\emph on
BayesRegression
\emph default
 the user must specify: 
\end_layout

\begin_layout Enumerate

yvec - one dimensional 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Numpy
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 array containing the data. 
\end_layout

\begin_layout Enumerate

xmat - two dimensional 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Numpy
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 array contain the regressors. 
\end_layout

\begin_layout Enumerate

**kwargs - optional arguments:
\end_layout

\begin_deeper
\begin_layout Enumerate

prior - a list contain the name of the prior and the corresponding hyperparameters. Examples: prior=[`normal_gamma', betaubar, Vubar, nuubar, Subar], prior=[`normal_inverted_gamma',betaubar, Vubar,nuubar, Subar] and prior=[`g_prior', betaubar, g]. If none of these options are chosen or they are miss-specified then the default prior will be Jeffreys' prior. 
\end_layout

\end_deeper
\begin_layout Standard


\emph on
BayesRegression 
\emph default
contains several functions that may be of interest to the user. In particular: 
\end_layout

\begin_layout Enumerate

sample() - returns a sample of 
\begin_inset Formula $\sigma$
\end_inset

 and 
\begin_inset Formula $\bm{\beta}$
\end_inset

 from the joint posterior distribution for the normal-inverted gamma prior, Jeffreys' prior and Zellner's g-prior. If the normal-gamma prior is specified then sample() returns 
\begin_inset Formula $\kappa$
\end_inset

 and 
\begin_inset Formula $\bm{\beta}.$
\end_inset

 
\end_layout

\begin_layout Enumerate

UpdateYvec(yvec) - updates yvec in 
\emph on
BayesRegression
\emph default
. This is often useful when the class is being used as a part of the MCMC sampling scheme. 
\end_layout

\begin_layout Enumerate

UpdateXmat(xmat) - updates xmat in 
\emph on
BayesRegression
\emph default
. This is often useful when the class is being used as a part of the MCMC sampling scheme. 
\end_layout

\begin_layout Enumerate

loglike(scale, beta) - returns the log-likelihood. 
\end_layout

\begin_layout Enumerate

posterior_mean() - returns the posterior mean for the scale parameter (either 
\begin_inset Formula $\sigma$
\end_inset

 or 
\begin_inset Formula $\kappa$
\end_inset

 depending on the specified prior) and 
\begin_inset Formula $\bm{\beta}.$
\end_inset

 
\end_layout

\begin_layout Enumerate

get_posterior_covmat() - returns the posterior covariance matrix for 
\begin_inset Formula $\bm{\beta}$
\end_inset

. 
\end_layout

\begin_layout Enumerate

bic() - returns the Bayesian information criterion. 
\end_layout

\begin_layout Enumerate

plot(**kwargs) - produces standard plots. Specifically the marginal posterior density intervales for each element of 
\begin_inset Formula $\bm{\beta}$
\end_inset

 and for the scale parameter (
\begin_inset Formula $\sigma$
\end_inset

 or 
\begin_inset Formula $\kappa)$
\end_inset

. 
\end_layout

\begin_layout Enumerate

residuals - returns the residual vector from the regression analysis. The residuals are calculated with 
\begin_inset Formula $\bm{\beta}$
\end_inset

 evaluated at the marginal posterior mean. 
\end_layout

\begin_layout Enumerate

output - produces standard output for the regression analysis. This includes the means, standard deviations and HPD intervals for the marginal posterior densities for each element of 
\begin_inset Formula $\bm{\beta}$
\end_inset

 and for the scale parameter (
\begin_inset Formula $\sigma$
\end_inset

 or 
\begin_inset Formula $\kappa)$
\end_inset

. The output also reports the log-likelihood and the Bayesian information criterion (BIC). 
\end_layout

\begin_layout Standard

In MCMC sampling schemes it is common that for a subset of the unknown parameters of interest the full conditional posterior distribution will correspond to that a linear regression model, where the scale parameter is known. For the linear regression model specified in (
\begin_inset LatexCommand ref
reference "eq:regression"

\end_inset

) the posterior distribution for the case that 
\begin_inset Formula $\sigma$
\end_inset

 is known is as follows
\begin_inset Formula \begin{equation} p(\bm{\beta})\propto
  p(\bm{y}|\bm{X},\bm{\beta},\sigma)\times
  p(\bm{\beta}),\label{eq:post_condbeta}\end{equation}
\end_inset

 where 
\begin_inset Formula $p(\bm{y}|\bm{X},\bm{\beta},\sigma)$
\end_inset

 is described in (
\begin_inset LatexCommand ref
reference "eq:likelihood regression"

\end_inset

) and 
\begin_inset Formula $p(\bm{\beta})$
\end_inset

 is the prior 
\emph on
pdf
\emph default
 for 
\begin_inset Formula $\bm{\beta}.$
\end_inset

 To sample from (
\begin_inset LatexCommand ref
reference "eq:post_condbeta"

\end_inset

) a class named 
\emph on
CondBetaRegSampler
\emph default
 can be used. The user may specify one of three alternative priors. The default prior is Jeffreys' prior, which for 
\begin_inset Formula $\bm{\beta}$
\end_inset

 is simply a flat prior over the real number line. A normally distributed prior for 
\begin_inset Formula $\bm{\beta}$
\end_inset

 is another option and can be specified such that
\begin_inset Formula \[ \bm{\beta}\sim
N\left(\underline{\beta},\bm{V}^{-1}\right).\]
\end_inset

 The user may also specify their 
\emph on
a priori
\emph default
 beliefs using Zellner's g-prior, where
\begin_inset Formula \[
\bm{\beta}|\sigma\sim
N\left(\bm{\beta},g\sigma^{2}\bm{X}^{T}\bm{X}\right).\]
\end_inset

 To initialise the class the user must specify: 
\end_layout

\begin_layout Enumerate

yvec - a one dimensional 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Numpy
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 array containing the data. 
\end_layout

\begin_layout Enumerate

xmat - a two dimensional 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Numpy
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 array containing the regressors. 
\end_layout

\begin_layout Enumerate

**kwargs - optional arguments:
\end_layout

\begin_deeper
\begin_layout Enumerate

prior - a list containing the name of the prior and the corresponding hyperparameters. Examples: prior=[`normal', betaubar, Vubar] or [`g_prior', betaubar, g]. If none of these options are chosen or they are miss-specified then the default prior will be Jeffreys' prior. 
\end_layout

\end_deeper
\begin_layout Standard

As many Bayesian models contain linear components with unknown scale parameters a class has been specified, named 
\emph on
CondScaleSampler
\emph default
, which can be used to individually sample scale parameters from their posterior distributions. In particular, we wish to sample from 
\begin_inset Formula \begin{equation} p(\sigma|\bm{y},\bm{\theta}),\label{eq:posterior
    sigma}\end{equation}
\end_inset

 where 
\begin_inset Formula $\bm{\theta}$
\end_inset

 is the set of unknown parameters of interest excluding 
\begin_inset Formula $\sigma.$
\end_inset

 The user may choose to use one of three priors. The Jeffreys' prior, which for 
\begin_inset Formula $\sigma$
\end_inset

 given the posterior in (
\begin_inset LatexCommand ref
reference "eq:posterior sigma"

\end_inset

) is as follows 
\begin_inset Formula \[
p(\sigma)\propto\frac{1}{\sigma}.\]
\end_inset

 Another option is to specify an inverted-gamma prior, such that
\begin_inset Formula \[ \sigma\sim
IG\left(\frac{\underline{\nu}}{2},\frac{\underline{S}}{2}\right).\]
\end_inset

 Alternatively, the user may specify a gamma prior for 
\begin_inset Formula $\kappa=\frac{1}{\sigma^{2}},$
\end_inset

 where
\begin_inset Formula \[ \kappa\sim
G\left(\frac{\underline{\nu}}{2},\frac{\underline{S}}{2}\right).\]
\end_inset

 To initialise the class 
\emph on
CondScaleSamper
\emph default
 the user may first specify: 
\end_layout

\begin_layout Enumerate

**kwargs - options arguments:
\end_layout

\begin_deeper
\begin_layout Enumerate

prior - list containing the name of the prior and the corresponding hyperparameters. Examples: prior=[`gamma',nuubar,subar] or [`inverted-gamma', nuubar, subar]. If no prior is specified the Jeffreys' prior is used. 
\end_layout

\end_deeper
\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 also includes another class that can be used for the direct analysis of the linear regression model. The class is called 
\emph on
StochasticSearch 
\emph default
and can be used in conjunction with the 
\emph on
MCMC
\emph default
 sampler for variable selection.
\end_layout

\begin_layout Standard

The stochastic search algorithm can be used for variable selection in the linear regression model. Given a set of 
\begin_inset Formula $k$
\end_inset

 possible regressors there is 
\begin_inset Formula $2^{k}$
\end_inset

 models to choose from. The stochastic search algorithm, as proposed by 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
citet{GeorgeMcCulloch1993}
\end_layout

\end_inset

, uses the Gibbs sampler to select a set of `most likely' models. The stochastic search algorithm is implemented in the class 
\emph on
StochasticSearch
\emph default
. The specific implementation follows 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
citet{MarinRobert2007}
\end_layout

\end_inset

. The algorithm introduces the vector 
\begin_inset Formula $\bm{\gamma},$
\end_inset

 which is used to select the explanatory variables that are to be included in the model. In particular, 
\begin_inset Formula $\bm{\gamma}$
\end_inset

 is defined to be a binary vector of order 
\begin_inset Formula $k$
\end_inset

, whereby the inclusion of the 
\begin_inset Formula $i^{th}$
\end_inset

regressor will imply that the 
\begin_inset Formula $i^{th}$
\end_inset

element of 
\begin_inset Formula $\bm{\gamma}$
\end_inset

 is a one, whilst the exclusion of the 
\begin_inset Formula $i^{th}$
\end_inset

 regressor implies that the 
\begin_inset Formula $i^{th}$
\end_inset

 element will be zero. It is assumed that the first element of the design matrix is always included and should typically be a column of ones which is used to represent the constant or intercept in the regression. The algorithm specified to sample 
\begin_inset Formula $\bm{\gamma}$
\end_inset

 is a single move Gibbs sampling scheme; for further details see 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
citet{MarinRobert2007}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard

To use the class 
\emph on
StochasticSearch 
\emph default
the user must specify their 
\emph on
a priori
\emph default
 beliefs that the unknown parameters of interest, 
\begin_inset Formula $(\sigma,\bm{\beta}^{T})^{T},$
\end_inset

 are specified according Zellner's g-prior, which is described in (
\begin_inset LatexCommand ref
reference "eq:g-prior"

\end_inset

). 
\emph on
StochasticSearch 
\emph default
is designed to be used in conjunction with the MCMC sampling class. To initialise 
\emph on
StochasticSearch
\emph default
 the user must specify: 
\end_layout

\begin_layout Enumerate

yvec - one dimensional 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Numpy
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 array containing the dependent variable. 
\end_layout

\begin_layout Enumerate

xmat - two dimensional 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Numpy
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 array containing the regressors. 
\end_layout

\begin_layout Enumerate

prior - list with the following structure [betaubar, g]. 
\end_layout

\begin_layout Standard

There is one function that is a member of 
\emph on
StochasticSearch
\emph default
 that may be useful. Specifically, 
\end_layout

\begin_layout Enumerate

sample_gamma(store) - returns a sample of 
\begin_inset Formula $\bm{\gamma}.$
\end_inset

 The only argument to pass into the function sample_gamma is the storage dictionary that is passed by default to each of the classes that are called from the class 
\emph on
MCMC 
\emph default
in 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

. 
\end_layout

\begin_layout Section

Empirical Illustrations
\end_layout

\begin_layout Standard


\begin_inset LatexCommand label
name "sec:Empirical-Illustrations"

\end_inset


\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 is illustrated though three examples. Specifically, a linear regression example with variable selection, a log-linear example and a linear regression model with first order autoregressive errors. For each example the model of interest is specified, then the code used in estimation is shown, following which a brief description describing each section of code is given. Each example uses the module for 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

, along with the 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 libraries 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Numpy
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Scipy
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 and Matplotlib. Example 3 further uses the library Pysparse.
\end_layout

\begin_layout Subsection

Example 1: Linear Regression Model: Variable selection and estimation
\end_layout

\begin_layout Standard

The 
\begin_inset Formula $i^{th}$
\end_inset

 observation 
\begin_inset Formula $y_{i},$
\end_inset

 for 
\begin_inset Formula $i=1,2,\dots,n,$
\end_inset

 is generated from
\begin_inset Formula \[ y_{i}=\mathbf{x}_{i}^{T}\bm{\beta}+\varepsilon_{i},\]
\end_inset

 where 
\begin_inset Formula $\bm{x}_{i}^{T}$
\end_inset

is the 
\begin_inset Formula $i^{th}$
\end_inset

row of the 
\begin_inset Formula $\left(n\times k\right)$
\end_inset

 matrix 
\begin_inset Formula $\bm{X},$
\end_inset

 
\begin_inset Formula $\bm{\beta}$
\end_inset

 is a 
\begin_inset Formula $(k\times1)$
\end_inset

 vector of regression coefficients and 
\begin_inset Formula $\varepsilon_{i}$
\end_inset

 is independently identically distributed (iid) following a normal distribution, with a mean of 0 and a variance of 
\begin_inset Formula $\sigma^{2}.$
\end_inset

 The data set of interest contains 19 regressors. To select the 'most probable' regressors we can use the stochastic search algorithm. This is implemented as follows:
\end_layout

\begin_layout Subsubsection

Example Code
\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{lstlisting}
\end_layout

\end_inset

[basicstyle=
\size scriptsize

\size default
,numbers=left] # example code for variable selection in regression
\end_layout

\begin_layout Standard

import os from numpy import loadtxt, hstack, ones, random, zeros, asfortranarray, log from pymcmc.mcmc import Gibbs, CFsampler from pymcmc.regtools import StochasticSearch, BayesRegression import pymcmc
\end_layout

\begin_layout Standard

""" get the path for the data. If this was installed using setup.py it will be in the data directory of the module""" datadir = os.path.join(os.path.dirname(pymcmc.file),'data')
\end_layout

\begin_layout Standard

def samplegamma(store): """function that samples vector of indicators""" return store['SS'].samplegamma(store)
\end_layout

\begin_layout Standard

# main program random.seed(12346)
\end_layout

\begin_layout Standard

# loads data data = loadtxt(os.path.join(datadir,'yld2.txt')) yvec = data[:, 0] xmat = data[:, 1:20] xmat = hstack([ones((xmat.shape[0], 1)), xmat])
\end_layout

\begin_layout Standard

"""data is a dictionary whose elements are accessible from the functions in the Gibbs sampler""" data =
\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

'yvec':yvec, 'xmat':xmat
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 prior = [zeros(xmat.shape[1]), 100.] SSVS = StochasticSearch(yvec, xmat, prior); data['SS'] = SSVS
\end_layout

\begin_layout Standard

"""initialise gamma""" initgamma = zeros(xmat.shape[1], dtype ='i') initgamma[0] = 1 simgam = CFsampler(samplegamma, initgamma, 'gamma', store ='none')
\end_layout

\begin_layout Standard

# initialise class for Gibbs samper GS = Gibbs(20000, 5000, data, [simgam]) GS.sampler() GS.output(filename ='vs.txt') GS.output(custom = SSVS.output, filename='SSVS.out') GS.output(custom = SSVS.output)
\end_layout

\begin_layout Standard

txmat = SSVS.extractregressors(0) gprior = ['gprior', 0.0, 100.] breg = BayesRegression(yvec,txmat,prior = gprior) breg.output() breg.plot() 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

The code uses requires the 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 libraries 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Numpy
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Scipy
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 and Matplotlib; see 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
citet{NumpyScipy,Matplotlib}
\end_layout

\end_inset

 for further details. The code is organised so that the user defined functions are at the top and the main program is at the bottom. Essentially the user defined functions that are called from the MCMC sampler, for which there is one in this case, all take the argument 
\emph on
store
\emph default
, which is a dictionary (
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 data structure) that is passed to all functions that are called from the MCMC sampler. The purpose of 
\emph on
store
\emph default
 is that it contains all the data required to define functions that sample from or are used in the evaluation of the posterior distribution. For example, in line 15, store['SS'] contains the class instance for 
\emph on
StochasticSearch
\emph default
. Essentially, any information that is stored in the dictionary 
\emph on
data
\emph default
, which is defined on line 30 and augmented to include the class instance for 
\emph on
StochasticSearch
\emph default
 defined on line 31 can be accessed from the dictionary 
\emph on
store
\emph default
. Note that the dictionary 
\emph on
data
\emph default
 is an argument that is used in the initialisation of the 
\emph on
MCMC
\emph default
 class on line 39. Apart from the information stored in 
\emph on
data,
\emph default
 the value of the previous iterate for each block of the Gibbs scheme is also a component of the dictionary store. For example on line 36 the class instance 
\emph on
simgam
\emph default
 is initialised. Note that the name 'gamma' is specified to refer to the parameter 
\begin_inset Formula $\bm{\gamma}.$
\end_inset

 If the user wanted to access the current iteration for 'gamma' from any of the functions called from 
\emph on
MCMC
\emph default
, this would simply be done using store['gamma']. This feature is not used in this example, but can be seen in the preceding examples. A brief description of the code is as follows: 
\end_layout

\begin_layout Itemize

Lines 3-7 import the classes and functions that are required in this example 
\end_layout

\begin_layout Itemize

Line 11 is used to obtain the path of the data if installed using setup.py. Note that this step will not be necessary for normal usage of 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

. 
\end_layout

\begin_layout Itemize

Lines 13-15 define the function that is used to sample 
\begin_inset Formula $\bm{\gamma}.$
\end_inset

 
\end_layout

\begin_layout Itemize

The main program starts at line 18. 
\end_layout

\begin_layout Itemize

Lines 21-24 are used to load the data, from which arrays 
\begin_inset Formula $\bm{y}$
\end_inset

 (yvec) and 
\begin_inset Formula $\bm{X}$
\end_inset

 (xmat) are constructed. 
\end_layout

\begin_layout Itemize

Lines 28-31 construct the dictionary 
\emph on
data
\emph default
, which includes 
\emph on
yvec, xmat
\emph default
 and the class instance of 
\emph on
StochasticSearch
\emph default
. 
\end_layout

\begin_layout Itemize

Line 36 defines the class instance 
\emph on
simgam
\emph default
, which defines the block of the MCMC scheme to sample 
\begin_inset Formula $\bm{\gamma}$
\end_inset

. 
\end_layout

\begin_layout Itemize

Line 39 defines the class instance of MCMC. Note that the Gibbs sampler will run for 20000 iterations, of which the first 5000 iterations will constitute the burnin and be discarded for the calculations in the output. The Gibbs sampler contains one block, which is defined by the class instance 
\emph on
simgam
\emph default
. 
\end_layout

\begin_layout Itemize

Line 40 runs the MCMC sampler. 
\end_layout

\begin_layout Itemize

Line 41 produces the standard output for the MCMC sampler, which is saved in the file 'vs.txt'. 
\end_layout

\begin_layout Itemize

Line 42 produces the custom output from the stochastic search class and is saved in the file 'SSVS.out'. 
\end_layout

\begin_layout Itemize

Line 43 produces the custom output for the stochastic search class and writes it to the screen. 
\end_layout

\begin_layout Itemize

Lines 45-48 produces regression output, from a Bayesian regression analysis based on the most probable model. 
\end_layout

\begin_layout Itemize

Line 49 produces standard plots from the Bayesian regression analysis. 
\end_layout

\begin_layout Subsubsection

Analysis
\end_layout

\begin_layout Standard

The data used in this example are a response of crop yield modelled using various chemical measurements from the soil. As the results of the chemical analysis of soil cores are done in a laboratory, many input variables are available (30) and the data analyst would like to determine which variables are most appropriate to use in the model.
\end_layout

\begin_layout Standard


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open


\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

Most likely models ordered by decreasing posterior probability
\end_layout

\begin_layout Standard

------------------------------------------------------------ probability | model ------------------------------------------------------------ 0.09353333 | 0,12 0.0504 | 0,11,12 0.026 | 0,10,12 0.01373333 | 0,9,12 0.01353333 | 0,8,12 0.013 | 0,4,12 0.01293333 | 0,12,19 0.01206667 | 0,7,12 0.01086667 | 0,11,12,17 0.01086667 | 0,12,17 ------------------------------------------------------------
\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

The MCMC analysis is conducted using 20000 iterations, of which the first 5000 are discarded. The estimation takes 10.35 seconds in total. The results indicate that a model containing variable 12 along with a constant is the most likely (prob = 0.09). Furthermore, variable 12 is contained in each of the 10 most likely models, indicating its strong association with crop yield.
\end_layout

\begin_layout Standard


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open


\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

--------------------------------------------------- Bayesian Linear Regression Summary gprior --------------------------------------------------- mean sd 2.5
\begin_inset ERT
status collapsed

\begin_layout Standard

%       97.5%
\end_layout

\begin_layout Standard


\end_layout

\end_inset

 beta[0] -0.1254 0.1058 -0.3361 0.08533 beta[1] 0.7587 0.0225 0.7139 0.8035 sigma 0.3853 0.03152 NA NA
\end_layout

\begin_layout Standard

loglikelihood = -4.143 marginal likelihood = nan BIC = -0.4017
\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

The parameter associated with variable 12, 
\begin_inset Formula $\hat{\beta_{1}}$
\end_inset

, is estimated as a positive value, 0.7587, with a 95% credible interval [0.7139,\InsetSpace ~
0.8035]. We note that zero is not contained in the credible interval, hence the crop yield increases with higher values of variable 12. The marginal posterior densities (Figure 
\begin_inset LatexCommand ref
reference "Flo:mpd   reg"

\end_inset

) illustrate that this effect is far from zero. 
\begin_inset Float figure
wide false
sideways false
status open


\begin_layout Standard
\align center


\begin_inset Graphics 
	filename mpdreg.pdf
	width 11cm

\end_inset

 
\end_layout

\begin_layout Standard


\begin_inset Caption

\begin_layout Standard
Marginal posterior density plots for the regression coefficients.
\end_layout

\end_inset

\end_layout

\begin_layout Standard


\begin_inset LatexCommand label
name "Flo:mpd reg"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection

Example 2: Log-linear Model
\end_layout

\begin_layout Standard


\begin_inset LatexCommand label
name "sub:Example-2:-Log-linear"

\end_inset


\end_layout

\begin_layout Standard

The 
\begin_inset Formula $i^{th}$
\end_inset

 observation 
\begin_inset Formula $y_{i}$
\end_inset

, for 
\begin_inset Formula $i=1,2,\dots,n$
\end_inset

, is generated as follows
\begin_inset Formula \begin{equation}
p(y_{i}|\mu_{i})=\frac{\mu_{i}^{y_{i}}\exp(-\mu_{i})}{\mu_{i}!},\label{eq:observation equation log linear model}\end{equation}
\end_inset

 with 
\begin_inset Formula \[
\log(\mu_{i})=\bm{x}_{i}^{T}\bm{\beta},\]
\end_inset

 where 
\begin_inset Formula $\bm{x}_{i}^{T}$
\end_inset

is the 
\begin_inset Formula $i^{th}$
\end_inset

row of the 
\begin_inset Formula $\left(n\times k\right)$
\end_inset

 matrix 
\begin_inset Formula $\bm{X}.$
\end_inset


\end_layout

\begin_layout Subsubsection

Posterior and Prior distributions: log linear model
\end_layout

\begin_layout Standard

The joint posterior distribution for the unknown parameter 
\begin_inset Formula $\bm{\beta}$
\end_inset

 is given by
\begin_inset Formula \begin{equation}
p(\bm{\beta}|\bm{y},\bm{X})\propto p(\bm{y}|\bm{\beta},\bm{X})\times p(\bm{\beta}),\label{eq:post log_linear}\end{equation}
\end_inset

 where 
\begin_inset Formula $p(\bm{y}|\bm{\beta},\bm{X})$
\end_inset

 is the joint 
\emph on
pdf 
\emph default
for 
\begin_inset Formula $\bm{y}$
\end_inset

 conditional on the 
\begin_inset Formula $\bm{\beta}$
\end_inset

 and 
\begin_inset Formula $\bm{X}$
\end_inset

, and 
\begin_inset Formula $p(\bm{\beta})$
\end_inset

 denotes the prior 
\emph on
pdf 
\emph default
for 
\begin_inset Formula $\bm{\beta}.$
\end_inset

 From (
\begin_inset LatexCommand ref
reference "eq:observation equation log linear model"

\end_inset

) it is apparent that
\begin_inset Formula \[
p(\bm{y}|\bm{\beta},\bm{X})=\prod_{i=1}^{n}\frac{\mu_{i}^{y_{i}}\exp(-\mu_{i})}{\mu_{i}!}.\]
\end_inset

 A 
\emph on
priori 
\emph default
we assume that 
\begin_inset Formula \[
\bm{\beta}\sim N(\bm{\underline{\bm{\beta}}},\bm{V}^{-1}).\]
\end_inset


\end_layout

\begin_layout Subsubsection

Estimation
\end_layout

\begin_layout Standard

To sample from (
\begin_inset LatexCommand ref
reference "eq:post log_linear"

\end_inset

), a random walk MH algorithm is implemented, where the candidate 
\begin_inset Formula $\bm{\beta}^{*}$
\end_inset

, at each iteration, is sampled following 
\begin_inset Formula \begin{equation}
\bm{\beta}^{*}\sim N\left(\bm{\beta}^{j-1},\bm{\Omega}\right),\label{eq:candidate log-linear}\end{equation}
\end_inset

 where
\begin_inset Formula \[
\bm{\beta}^{0}=\bm{\beta}_{nls}=\arg\min\left(\bm{y}-\exp\left(\bm{X}\bm{\beta}\right)\right)^{2}\]
\end_inset

 and
\begin_inset Formula \[
\bm{\Omega}^{-1}=-\sum_{i=1}^{n}\exp\left(\bm{x}_{i}^{T}\bm{\beta}_{nls}\right)\bm{x}_{i}\bm{x}_{i}^{T}.\]
\end_inset


\end_layout

\begin_layout Subsubsection

Example Code
\end_layout

\begin_layout Standard

The example code for 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 uses two 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 libraries, 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Numpy
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 and 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Scipy
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

, which the user must have installed on their system to run the code. The code for the program is as follows:
\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{lstlisting}
\end_layout

\end_inset

[basicstyle=
\size scriptsize

\size default
,numbers=left] #!/usr/bin/env python # bayesian MCMC estimation of the log - linear model
\end_layout

\begin_layout Standard

import os from numpy import random, loadtxt, hstack, ones, dot, exp, zeros, outer, diag from numpy import linalg from pymcmc.mcmc import Gibbs, RWMH, OBMC from pymcmc.regtools import BayesRegression from scipy.optimize.minpack import leastsq import pymcmc
\end_layout

\begin_layout Standard

""" Get the path for the data. If this was installed using setup.py it will be in the data directory of the module""" datadir = os.path.join(os.path.dirname(pymcmc.file), 'data')
\end_layout

\begin_layout Standard

def minfunc(beta, yvec, xmat ): """function used by nonlinear least squares routine""" return yvec - exp(dot(xmat, beta))
\end_layout

\begin_layout Standard

def prior(store): """function evaluates the prior pdf for beta""" mu = zeros(store['beta'].shape[0]) Prec = diag(0.005 * ones(store['beta'].shape[0])) return -0.5 * dot(store['beta'].transpose(), dot(Prec, store['beta']))
\end_layout

\begin_layout Standard

def logl(store): """function evaluates the log - likelihood for the log - linear model""" xbeta = dot(store['xmat'], store['beta']) lamb = exp(xbeta) return sum(store['yvec'] * xbeta - lamb)
\end_layout

\begin_layout Standard

def posterior(store): """function evaluates the posterior probability for the log - linear model""" return logl(store) + prior(store)
\end_layout

\begin_layout Standard

def llhessian(store, beta): """function returns the hessian for the log - linear model""" nobs = store['yvec'].shape[0] kreg = store['xmat'].shape[1] lamb = exp(dot(store['xmat'], beta)) sum = zeros((kreg, kreg)) for i in xrange(nobs): sum = sum + lamb[i] * outer(store['xmat'][i], store['xmat'][i]) return -sum
\end_layout

\begin_layout Standard

# main program random.seed(12345) # seed or the random number generator
\end_layout

\begin_layout Standard

data = loadtxt(os.path.join(datadir,'count.txt'), skiprows = 1) # loads data from file yvec = data[:, 0] xmat = data[:, 1:data.shape[1]] xmat = hstack([ones((data.shape[0], 1)), xmat])
\end_layout

\begin_layout Standard

data =
\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

'yvec':yvec, 'xmat':xmat
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 bayesreg = BayesRegression(yvec, xmat) # use bayesian regression to initialise # nonlinear least squares algorithm sig, beta0 = bayesreg.posteriormean() initbeta, info = leastsq(minfunc, beta0, args = (yvec, xmat)) data['betaprec'] =-llhessian(data, initbeta) scale = linalg.inv(data['betaprec'])
\end_layout

\begin_layout Standard

samplebeta = RWMH(posterior, scale, initbeta, 'beta') GS = Gibbs(20000, 4000, data, [samplebeta], loglike = (logl, xmat.shape[1], 'yvec')) GS.sampler() GS.output(filename='example1c.out') GS.plot('beta', filename='example1c.eps') # GS.CODAoutput('beta') # GS.plot('beta', elements = [0], plottypes ="trace", filename ="xx.pdf") # GS.plot('beta', elements = [0], plottypes ="density", filename ="xx.png") ## GS.plot('beta', elements = [0], plottypes ="acf", filename ="yy.ps")
\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

The code for the analysis of the log-linear model is used to demonstrate an application of straight Metropolis Hastings based algorithms. The 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 libraries 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Numpy
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 and 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Scipy
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 are required along with 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

. A brief description of the code is as follows: 
\end_layout

\begin_layout Itemize

Lines 4-10 import the required classes and functions that are used in the program. 
\end_layout

\begin_layout Itemize

Line 14 is used to obtain the path of the data if installed using setup.py. Note that this step will not be necessary for normal usage of 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

. 
\end_layout

\begin_layout Itemize

Lines 16-18 defines a function, 
\emph on
minfunc,
\emph default
 which is required in the non-linear least squares routine. 
\end_layout

\begin_layout Itemize

Lines 20-24 defines a function that evaluates the log of the prior pdf for, 
\begin_inset Formula $\bm{\beta}.$
\end_inset

 As in the variable selection example, 
\emph on
store
\emph default
 is a 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 dictionary used to store all the information of interest that needs to be accessed by functions that are called from the MCMC sampler. For example, on line 22 it can be seen that store['beta'] provides access to the vector 
\begin_inset Formula $\bm{\beta}.$
\end_inset

 Note the name 'beta' is specified on line 72 when the class for the random walk MH algorithm is initialised. 
\end_layout

\begin_layout Itemize

Lines 26-30 defines the log-likelihood function. 
\end_layout

\begin_layout Itemize

Lines 32-34 defines a function that evaluates the log of the posterior pdf for 
\begin_inset Formula $\bm{\beta}.$
\end_inset

 
\end_layout

\begin_layout Itemize

Lines 36-44 defines a function that returns the hessian for the log-linear model. 
\end_layout

\begin_layout Itemize

The main program begins on line 47. 
\end_layout

\begin_layout Itemize

Lines 49-52 load the data, from which arrays 
\begin_inset Formula $\bm{y}$
\end_inset

 (yvec) and 
\begin_inset Formula $\bm{X}$
\end_inset

 (xmat) are constructed. 
\end_layout

\begin_layout Itemize

Line 62 initialises the class 
\emph on
RWMH
\emph default
. 
\end_layout

\begin_layout Itemize

Line 63 initialises the class 
\emph on
MCMC
\emph default
 . Note that the sampling algorithm will be run for 20000 iterations and the first 4000 will be discarded. The MCMC scheme has only one block and is a MH sampling scheme. 
\end_layout

\begin_layout Itemize

Line 64 runs the sampling scheme. 
\end_layout

\begin_layout Itemize

Lines 65-66 produce output. 
\end_layout

\begin_layout Itemize

Lines 67-70 have been commented out, but they are there to demonstrate an example of how to produce CODA output and different ways in which plotting may be produced. 
\end_layout

\begin_layout Subsubsection

Analysis
\end_layout

\begin_layout Standard

The data analysed in this example are the number of nutgrass shoots counted, in randomly scattered quadrats, at weekly intervals, during the growing season. A log linear model is used; 
\begin_inset Formula \begin{equation}
  \log(\mbox{count})=\beta_{0}+\beta_{1}\mbox{week}\end{equation}
\end_inset

 where the intercept, 
\begin_inset Formula $\beta_{0}$
\end_inset

, is expected to be positive in value, as nutgrass is always present, and 
\begin_inset Formula $\beta_{1}$
\end_inset

 is also expected to be positive as the population of nutgrass increases during the growing season.
\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

--------------------------------------------------------
\end_layout

\begin_layout Standard

The time (seconds) for the Gibbs sampler = 7.47 Number of blocks in Gibbs sampler = 1
\end_layout

\begin_layout Standard

mean sd 2.5
\begin_inset ERT
status collapsed

\begin_layout Standard

%     97.5%    IFactor
\end_layout

\begin_layout Standard


\end_layout

\end_inset

 beta[0] 1.14 0.0456 1.05 1.23 13.5 beta[1] 0.157 0.00428 0.148 0.165 12.2 Acceptance rate beta = 0.5625 BIC = -7718.07405717 Log likelihood = 3864.45312899
\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

It can be seen from the output that estimation is very fast (7.3 seconds), and that both 
\begin_inset Formula $\beta_{0}$
\end_inset

 and 
\begin_inset Formula $\beta_{1}$
\end_inset

 are positive values, with 
\begin_inset Formula $\hat{\beta}_{0}$
\end_inset

 = 1.14 [1.05, 1.23] and 
\begin_inset Formula $\hat{\beta}_{1}$
\end_inset

 = 0.157 [0.149, 0.165]. We note that zero is not contained in the credible intervals and the marginal posterior densities of these estimates (Figure 2) illustrate that both estimates are far from zero.
\end_layout

\begin_layout Standard

The ACF plots (Figure 2) and low inefficiency factors of 12.6 (
\begin_inset Formula $\hat{\beta}_{0}$
\end_inset

) and 11.4 (
\begin_inset Formula $\hat{\beta}_{1}$
\end_inset

) show that autocorrelation in the sample is low. 
\begin_inset Float figure
wide false
sideways false
status open


\begin_layout Standard


\begin_inset Caption

\begin_layout Standard
Plots of the marginal posterior density, autocorrelation and trace plots for the MCMC estimation of the log linear model.
\end_layout

\end_inset

\end_layout

\end_inset


\end_layout

\begin_layout Subsection

Example 3: First order autoregressive regression
\end_layout

\begin_layout Standard


\begin_inset LatexCommand label
name "sub:Example-3:-First"

\end_inset


\end_layout

\begin_layout Standard

Denote the 
\begin_inset Formula $t^{th}$
\end_inset

 observation as 
\begin_inset Formula $y_{t},$
\end_inset

then for 
\begin_inset Formula $t=1,2,\dots,n,$
\end_inset


\begin_inset Formula \begin{equation}
  y_{t}=\bm{x}_{t}^{T}\bm{\beta}+\varepsilon_{t},\label{eq:observation
    ar}\end{equation}
\end_inset

 with
\begin_inset Formula \begin{equation}
  \varepsilon_{t}=\rho\varepsilon_{t-1}+\nu_{t};\,\,\,\nu_{t}\sim
  i.i.d.N(0,\sigma^{2}),\label{eq:error ar}\end{equation}
\end_inset

 where 
\series bold

\begin_inset Formula $\bm{x}_{t}$
\end_inset


\series default
 is a 
\begin_inset Formula $\left(k\times1\right)$
\end_inset

 vector of regressors, 
\begin_inset Formula $\bm{\beta}$
\end_inset

 is a 
\begin_inset Formula $\left(k\times1\right)$
\end_inset

 vector of regression coefficients, 
\begin_inset Formula $\rho$
\end_inset

 is a damping parameter and 
\begin_inset Formula $\nu_{t}$
\end_inset

 is an independent identically normally distributed random variable with a mean of 0 and a variance of 
\begin_inset Formula $\sigma^{2}.$
\end_inset

 Under the assumption the the process driving the errors are stationary, that is 
\begin_inset Formula $|\rho|<1,$
\end_inset

 and assuming that the process has been running since time immemorial then (
\begin_inset LatexCommand ref
reference "eq:observation ar"

\end_inset

) and (
\begin_inset LatexCommand ref
reference "eq:error ar"

\end_inset

) can be expressed as
\end_layout

\begin_layout Standard


\begin_inset Formula \begin{equation}
\bm{y}=\bm{X}\bm{\beta}+\bm{\varepsilon};\,\,\,\,\bm{\varepsilon}\sim N\left(\bm{0},\kappa^{-1}\bm{\Omega^{-1}}\right),\label{eq:observation2 ar}\end{equation}
\end_inset

 where 
\begin_inset Formula \[
\bm{\Omega}=\left[\begin{array}{cccccc}
1 & -\rho & 0 & 0 & \cdots & 0\\
-\rho & 1+\rho^{2} & -\rho & 0 & \ddots & 0\\
0 & -\rho & 1+\rho^{2} & \ddots & \ddots & \vdots\\
0 & 0 & \ddots & \ddots & -\rho & 0\\
\vdots & \vdots & \ddots & -\rho & 1+\rho^{2} & -\rho\\
0 & 0 & \cdots & 0 & -\rho & 1\end{array}\right].\]
\end_inset

 Further, if we factorise 
\begin_inset Formula $\bm{\Omega}=\bm{L}\bm{L}^{T},$
\end_inset

 using the Cholesky decomposition, it is straightforward to derive 
\begin_inset Formula $\bm{L},$
\end_inset

 where
\begin_inset Formula \[
\bm{L}=\left[\begin{array}{cccccc}
1 & -\rho & 0 & 0 & \cdots & 0\\
0 & 1 & -\rho & \ddots & \ddots & 0\\
0 & 0 & \ddots & \ddots & \ddots & \vdots\\
\vdots & \ddots & \ddots & \ddots & \ddots & 0\\
\vdots & \ddots & \ddots & \ddots & 1 & -\rho\\
0 & 0 & \cdots & \cdots & 0 & \sqrt{1-\rho^{2}}\end{array}\right].\]
\end_inset

 Pre-multiplying (
\begin_inset LatexCommand ref
reference "eq:observation2 ar"

\end_inset

), by 
\begin_inset Formula $\bm{L}$
\end_inset

 gives
\begin_inset Formula \begin{equation}
\bm{\tilde{y}}=\bm{\tilde{X}}\bm{\beta}+\bm{\tilde{\varepsilon}},\label{eq:trans_obs_ar}\end{equation}
\end_inset

 where 
\begin_inset Formula $\bm{\tilde{y}}=\bm{L}^{T}\bm{y}$
\end_inset

, 
\begin_inset Formula $\bm{\tilde{X}}=\bm{L}^{T}\bm{X}$
\end_inset

 and 
\begin_inset Formula $\tilde{\bm{\varepsilon}}=\bm{L}^{T}\bm{\varepsilon}.$
\end_inset

 Note that 
\begin_inset Formula $\bm{\varepsilon}\sim N(0,\kappa^{-1}\bm{I})$
\end_inset

.
\end_layout

\begin_layout Subsubsection

Posterior and Prior Distributions: First order Autoregression
\end_layout

\begin_layout Standard

The joint posterior distribution for full set of unknown parameters is
\begin_inset Formula \begin{equation} p(\bm{\beta},\kappa,\rho|\bm{y})\propto
  p(\bm{y}|\bm{\beta},\kappa,\rho)\times p(\bm{\beta},\kappa)\times
  p(\rho),\label{eq:post_ar}\end{equation}
\end_inset

 where 
\begin_inset Formula $p(\bm{y}|\bm{\beta},\kappa,\rho)$
\end_inset

 is the joint 
\emph on
pdf
\emph default
 of 
\begin_inset Formula $\bm{y}$
\end_inset

 conditional on 
\begin_inset Formula $\bm{\beta},$
\end_inset

 
\begin_inset Formula $\kappa,$
\end_inset

 and 
\begin_inset Formula $\rho$
\end_inset

, 
\begin_inset Formula $p(\bm{\beta},\kappa)$
\end_inset

 is the joint prior 
\emph on
pdf
\emph default
 for 
\begin_inset Formula $\bm{\beta}$
\end_inset

 and 
\begin_inset Formula $\kappa,$
\end_inset

 and 
\begin_inset Formula $p(\rho)$
\end_inset

 denotes the prior density function for 
\begin_inset Formula $\rho.$
\end_inset

 The likelihood function, which is defined following (
\begin_inset LatexCommand ref
reference "eq:observation ar"

\end_inset

) and (
\begin_inset LatexCommand ref
reference "eq:error ar"

\end_inset

) is defined as follows
\begin_inset Formula \begin{eqnarray}
  p(\bm{y}|\bm{\beta},\kappa,\rho) & \propto & \kappa^{n/2}|\bm{\Omega}|^{1/2}\exp\left\{ -\frac{\kappa}{2}\left(\bm{y}-\bm{X}\bm{\beta}\right)^{T}\bm{\Omega}\left(\bm{y}-\bm{X}\bm{\beta}\right)\right\} \nonumber \\
  & = & \kappa^{n/2}|\bm{\Omega}|^{1/2}\exp\left\{ -\frac{\kappa}{2}\left(\tilde{\bm{y}}-\tilde{\bm{X}}\bm{\beta}\right)^{T}\left(\tilde{\bm{y}}-\tilde{\bm{X}}\bm{\beta}\right)\right\} .\nonumber \\
  & = & \kappa^{n/2}\left(1-\rho^{2}\right)^{1/2}\exp\left\{
    -\frac{\kappa}{2}\left(\tilde{\bm{y}}-\tilde{\bm{X}}\bm{\beta}\right)^{T}\left(\tilde{\bm{y}}-\tilde{\bm{X}}\bm{\beta}\right)\right\}
  .\label{eq:Likelihood AR1}\end{eqnarray}
\end_inset

 For the analysis a normal-gamma prior is assumed for 
\begin_inset Formula $\bm{\beta}$
\end_inset

 and 
\begin_inset Formula $\kappa$
\end_inset

, such that
\begin_inset Formula \begin{equation} \bm{\beta}|\kappa\sim
  N\left(\underline{\bm{\beta}},\kappa^{-1}\right),\,\,\,\,\,\kappa\sim
  G\left(\frac{\underline{\nu}}{2},\frac{\underline{S}}{2}\right).\label{eq:prior
    beta AR1}\end{equation}
\end_inset

 It follows from (
\begin_inset LatexCommand ref
reference "eq:Likelihood AR1"

\end_inset

) and (
\begin_inset LatexCommand ref
reference "eq:prior beta AR1"

\end_inset

) that sampling 
\begin_inset Formula $\bm{\beta}$
\end_inset

 and 
\begin_inset Formula $\kappa$
\end_inset

 conditional on 
\begin_inset Formula $\rho$
\end_inset

 is simply equivalent to sampling from a linear regression model with a normal-gamma prior. A beta prior is assumed for 
\begin_inset Formula $\rho$
\end_inset

 there by restricting the autocorrelation of the time series to be both positive and stationary. Specifically
\begin_inset Formula \[
\rho\sim\mathcal{B}e\left(\alpha,\beta\right).\]
\end_inset


\end_layout

\begin_layout Subsubsection

MCMCSampling Scheme: First order autoregressive regression
\end_layout

\begin_layout Standard

A MCMC sampling scheme, for the posterior distribution in (
\begin_inset LatexCommand ref
reference "eq:post_ar"

\end_inset

), defined at iteration 
\begin_inset Formula $j$
\end_inset

 is as follows: 
\end_layout

\begin_layout Enumerate

Sample 
\begin_inset Formula $\bm{\beta}^{(j)},\kappa^{(j)}$
\end_inset

 from 
\begin_inset Formula $p(\bm{\beta},\kappa|\bm{y},\rho^{(j-1)}).$
\end_inset

 
\end_layout

\begin_layout Enumerate

Sample 
\begin_inset Formula $\rho^{(j)}$
\end_inset

 from 
\begin_inset Formula $p(\rho|\bm{y},\bm{\beta},\kappa).$
\end_inset

 
\end_layout

\begin_layout Subsubsection

Code
\end_layout

\begin_layout Standard

The example code for the linear regression model, with first order autocorrelation in the errors uses the 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 libraries 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Numpy
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Scipy
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 and Pysparse. The code is used to analyse simulated data.
\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{lstlisting}
\end_layout

\end_inset

[basicstyle=
\size scriptsize

\size default
,numbers=left,tabsize=4] # example linear regression model with first order autocorrelation in the errors
\end_layout

\begin_layout Standard

from numpy import random, ones, zeros, dot, hstack, eye, log from scipy import sparse from pysparse import spmatrix from pymcmc.mcmc import Gibbs, SliceSampler, RWMH, OBMC, MH, CFsampler from pymcmc.regtools import BayesRegression
\end_layout

\begin_layout Standard

def simdata(nobs, kreg): """function simulates data from a first order autoregressive regression""" xmat = hstack((ones((nobs, 1)), random.randn(nobs, kreg - 1))) beta = random.randn(kreg) sig = 0.2 rho = 0.90 yvec = zeros(nobs) eps = zeros(nobs) eps[0] = sig**2/(1.-rho**2) for i in xrange(nobs - 1): eps[i + 1] = rho * eps[i] + sig * random.randn(1) yvec = dot(xmat, beta) + eps return yvec, xmat
\end_layout

\begin_layout Standard

def calcweighted(store): """re - weights yvec and xmat, for use in weighted least squares regression""" nobs = store['yvec'].shape[0] store['Upper'].put(-store['rho'], range(0, nobs - 1), range(1, nobs)) store['Upper'].matvec(store['yvec'], store['yvectil']) for i in xrange(store['xmat'].shape[1]): store['Upper'].matvec(store['xmat'][:, i], store['xmattil'][:, i])
\end_layout

\begin_layout Standard

def WLS(store): """computes weighted least square regression""" calcweighted(store) store['regsampler'].UpdateYvec(store['yvectil']) store['regsampler'].UpdateXmat(store['xmattil']) return store['regsampler'].sample()
\end_layout

\begin_layout Standard

def loglike(store): """calculates log - likelihood for the the first order autoregressive regression model""" nobs = store['yvec'].shape[0] calcweighted(store) store['regsampler'].UpdateYvec(store['yvectil']) store['regsampler'].UpdateXmat(store['xmattil']) return store['regsampler'].loglike(store['sigma'], store['beta'])
\end_layout

\begin_layout Standard

def priorrho(store): """evaulates the log of the prior distribution for rho. the beta distribution is used""" if store['rho'] > 0. and store['rho'] < 1.0: alpha = 1.0 beta = 1.0 return (alpha - 1.) * log(store['rho']) + (beta - 1.) * log(1.-store['rho']) else: return -1E256
\end_layout

\begin_layout Standard

def postrho(store): """evaulates the log of the posterior distrbution for rho""" return loglike(store) + priorrho(store)
\end_layout

\begin_layout Standard

# testfunctions used to test generic MH algorithm def gencand(store): return store['rho'] + 0.02 * random.randn(1)[0]
\end_layout

\begin_layout Standard

def probcandgprev(store): res = store['rho'] - store['previousrho'] return -0.5/(0.02**2) * res**2
\end_layout

\begin_layout Standard

def probprevgcand(store): return probcandgprev(store)
\end_layout

\begin_layout Standard

# Main program random.seed(12345) nobs = 1000 kreg = 3
\end_layout

\begin_layout Standard

yvec, xmat = simdata(nobs, kreg)
\end_layout

\begin_layout Standard

# we use a g - prior for the regression coefficients. priorreg = ('gprior', zeros(kreg), 1000.0) regs = BayesRegression(yvec, xmat, prior = priorreg)
\end_layout

\begin_layout Standard

"""A dictionary is set up. The contents of the dictionary will be available for use for by the functions that make up the Gibbs sampler. Note that we pass in storage space as well as the class intance used to sample the regression from.""" data =
\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

'yvec':yvec, 'xmat':xmat, 'regsampler':regs
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 U = spmatrix.llmat(nobs, nobs, 2 * nobs - 1) U.put(1.0, range(0, nobs), range(0, nobs)) data['yvectil'] = zeros(nobs) data['xmattil'] = zeros((nobs, kreg)) data['Upper'] = U
\end_layout

\begin_layout Standard

# Use Bayesian regression to initialise MCMC sampler bayesreg = BayesRegression(yvec, xmat) sig, beta = bayesreg.posteriormean()
\end_layout

\begin_layout Standard

simsigbeta = CFsampler(WLS, [sig, beta], ['sigma', 'beta']) scale = 0.002 # tuning parameter for RWMH rho = 0.9 ##rho = [1] ## to test exception handling # simrho = RWMH(postrho, scale, rho, 'rho') simrho = SliceSampler([postrho], 0.1, 5, rho, 'rho') #simrho = OBMC(postrho, 3, scale, rho, 'rho') # simrho = MH(gencand, postrho, probcandgprev, probprevgcand, rho, 'rho') blocks = [simrho, simsigbeta] loglikeinfo = (loglike, kreg + 2, 'yvec') ms = MCMC(10000, 2000, data, blocks, loglike = loglikeinfo) ms.sampler() ms.output() #GS.plot('sigbeta') GS.plot('rho', filename ='rho') GS.CODAoutput(parameters = ['rho'])
\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

A brief description of the code above is as follows: 
\end_layout

\begin_layout Itemize

Lines 3-7 import the specific functions and classes that are used in the analysis. 
\end_layout

\begin_layout Itemize

Lines 9-21 define a function that is used to produce the simulated data. 
\end_layout

\begin_layout Itemize

Lines 23-29 define a function that calculates 
\begin_inset Formula $\tilde{\bm{y}}$
\end_inset

 and 
\begin_inset Formula $\bm{\tilde{X}}.$
\end_inset

 Note that line 26 updates 
\begin_inset Formula $\bm{L}^{T}$
\end_inset

 based on the latest iteration in the MCMC scheme. Note that 
\begin_inset Formula $\bm{L}^{T}$
\end_inset

 is stored in the 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 dictionary 
\emph on
store
\emph default
 and is accessed using the key 'Upper'. It is stored in sparse matrix format using the library Pysparse. 
\end_layout

\begin_layout Itemize

Lines 31-36 define a function that is used to sample 
\begin_inset Formula $\bm{\beta},$
\end_inset

 from its conditional posterior distribution. 
\end_layout

\begin_layout Itemize

Lines 38-44 define a function that evaluates the log-likelihood 
\end_layout

\begin_layout Itemize

Lines 46-53 define the log of the prior pdf for 
\begin_inset Formula $\rho$
\end_inset

. 
\end_layout

\begin_layout Itemize

Lines 55-57 define a function that evaluates the log of the posterior pdf for 
\begin_inset Formula $\rho.$
\end_inset

 
\end_layout

\begin_layout Itemize

Lines 61 to 69 define functions that can be used to demonstrate the generic MH algorithm. 
\end_layout

\begin_layout Itemize

The main program begins on line 72. 
\end_layout

\begin_layout Itemize

Lines 86-91 construct the 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 dictionary data, which is used to store information that will be passed to functions that are called from the MCMC sampler. 
\end_layout

\begin_layout Itemize

Line 97 initialises the class instance 
\emph on
simsigbeta
\emph default
, which is used to jointly sample 
\begin_inset Formula $\sigma$
\end_inset

 and 
\begin_inset Formula $\bm{\beta}.$
\end_inset

 
\end_layout

\begin_layout Itemize

Line 101 provides an example of how to set up 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 to sample 
\begin_inset Formula $\rho$
\end_inset

 using the random walk MH algorithm. 
\end_layout

\begin_layout Itemize

Line 102 provides an example of how to set up 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 to sample 
\begin_inset Formula $\rho$
\end_inset

 using the Slice Sampler. This is the method that is used in the analysis below. 
\end_layout

\begin_layout Itemize

Line 103 provides and example of how to set up 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 to sample 
\begin_inset Formula $\rho$
\end_inset

 using the OBMC algorithm. Note that the OBMC algorithm is set up to use three trials. 
\end_layout

\begin_layout Itemize

Line 104 provides an example of how to set up 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 to sample 
\begin_inset Formula $\rho$
\end_inset

 using the generic MH algorithm. 
\end_layout

\begin_layout Itemize

Line 105 constructs a 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 list that contain the class instances that define the MCMC sampler. In particular, it implies that the MCMC sampler consists of two blocks. Further, 
\begin_inset Formula $\rho$
\end_inset

 will be the first element sampled in the MCMC scheme. 
\end_layout

\begin_layout Itemize

Line 107 initialises 
\emph on
MCMC
\emph default
. The MCMC sampler is run for 8000 iterations and the first 2000 iterations are discarded in this instance. 
\end_layout

\begin_layout Itemize

Line 108 runs the sampler. 
\end_layout

\begin_layout Itemize

Lines 109-112 produce output from the MCMC sampler. 
\end_layout

\begin_layout Subsubsection

Output
\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

The time (seconds) for the Gibbs sampler = 27.72 Number of blocks in Gibbs sampler = 2
\end_layout

\begin_layout Standard

mean sd 2.5
\begin_inset ERT
status collapsed

\begin_layout Standard

%     97.5%    IFactor
\end_layout

\begin_layout Standard


\end_layout

\end_inset

 beta[0] -0.523 0.0716 -0.653 -0.373 3.5 beta[1] 1.85 0.00508 1.84 1.86 3.56 beta[2] 0.455 0.00505 0.445 0.465 3.75 sigma 0.217 0.00489 0.207 0.226 3.5 rho 0.901 0.0155 0.872 0.932 3.67
\end_layout

\begin_layout Standard

Acceptance rate beta = 1.0 Acceptance rate sigma = 1.0 Acceptance rate rho = 1.0 BIC = [-331.39844466] Log likelihood = [ 182.96861053]
\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

The analysis is conducted on a simulated data set, with 1000 observations and 3 regressors. The MCMC sampler is run for 10000 iterations and the first 2000 are discarded. The total time of estimation is approximately 35 seconds. From the inefficiency factors it is clear that the algorithm is very efficient.
\end_layout

\begin_layout Standard


\begin_inset Float figure
placement h
wide false
sideways false
status open


\begin_layout Standard

 
\begin_inset LatexCommand label
name "Flo:AR1"

\end_inset


\end_layout

\begin_layout Standard


\begin_inset Caption

\begin_layout Standard
Marginal posterior density, autocorrelation function and trace plot based on the MCMC analysis.
\end_layout

\end_inset

\end_layout

\end_inset


\end_layout

\begin_layout Standard

Figure 
\begin_inset LatexCommand ref
reference "Flo:AR1"

\end_inset

 plots the marginal posterior density, autocorrelation plot and the trace plot for the iterates.
\end_layout

\begin_layout Section


\begin_inset OptArg
status collapsed


\begin_layout Standard

Using PyMCMC efficiently
\end_layout

\end_inset

Using 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 efficiently
\end_layout

\begin_layout Standard


\begin_inset LatexCommand label
name "sec:Using-PyMCMC-efficiently"

\end_inset


\end_layout

\begin_layout Standard

The fact that MCMC algorithms rely on a large number of iterations to achieve reasonable results and are often implemented on very large problems, dictates that the user must have the required machinery to implement efficient code. In MCMC analysis, efficiency comes through an understanding of what makes a simulation efficient MCMC sampler, and also the ability to produce computationally efficient code. Interestingly, the two are related. To achieve simulation efficient code in MCMC samplers it is often extremely important that large numbers of parameters are blocked together. A classic example in the literature are using 
\emph on
simulation smoothers 
\emph default
to jointly sample the state vector in a state space model; see for example
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
citet{CarterKohn1994}
\end_layout

\end_inset

 and 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
citet{deJongShepard1995}
\end_layout

\end_inset

. Whilst implementing a simulation smoother is required to achieve simulation efficient code, the sequential nature of their implementation often renders higher level languages impractical for large problems and thus forces the analyst to write their entire code in lower level languages. This is an inefficient use of time as usually only small percentage of code needs to be optimised. This drawback is easily circumvented in 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 as 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 makes it easy to use a lower level language to write the specialised module and use the function directly from 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

. This ensures 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

's modules can be used for rapid development from 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 and lower level languages are only resorted to when necessary. This Section aims to provide guidelines for producing efficient code with 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

. We discuss alternative external libraries that are available to the user for producing efficient code using 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

. Despite the ease of writing specialised modules this should not be the first resort of the user. Instead, one should ensure that the 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 prototypes are efficiently coded using the resources available with 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard

Arguably, the first thing the user of 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 should concentrate on when optimising there 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 code is to ensure they use as many inbuilt functions and libraries as possible. As most high performance libraries are written in 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

C
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 or 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Fortran
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 this ensures that computationally expensive procedures are computed using code from compiled languages. 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 users, and hence 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 users, have an enormous resource of Scientific libraries available to them as a result of the popularity of 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 in the scientific community. Two of the most important libraries for most users, will quite possibly be, 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Numpy
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 and 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Scipy
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

. Making use of such libraries is one of the best ways of avoiding large loops in procedures that are called from the MCMC sampler. If a large loop is used inside a function that is called from inside the MCMC sampler then this could mean a large proportion of the total computation is being done by 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

, rather than a library that was generated from optimised compiled code. This can have a dramatic effect on the total computation time. As a simple and somewhat trivial example we modify Example 
\begin_inset LatexCommand ref
reference "sub:Example-2:-Log-linear"

\end_inset

 so that a loop is explicitly used to calculate the log likelihood.
\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{lstlisting}
\end_layout

\end_inset

[basicstyle=
\size scriptsize

\size default
] def logl(store): """function evaluates the log - likelihood for the log - linear model""" suml=0.0 for i in xrange(store['yvec'].shape[0]): xbeta=dot(store['xmat'][i,:],store['beta']) suml=suml+store['yvec'][i] * xbeta - exp(xbeta) return suml 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

Whilst the two functions to calculate the log-likelihood are mathematically equivalent, the one with the explicit loop is substantially slower. Specifically, the time taken for the MCMC sampler went from 7.3 seconds to 130.19 seconds. As such, this minor modification leads to an approximately 18 times decrease in the speed of the program.
\end_layout

\begin_layout Standard

If the use of an an inbuilt function is not possible and the time taken from the program is unacceptable then there are several alternative solutions available to the user. One such solution is to use the package 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Weave
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

, which is a part of the 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Scipy
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 library, to write inline 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

C
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 code which will accelerate the problem area in the code. An example is given below.
\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{lstlisting}
\end_layout

\end_inset

[basicstyle=
\size scriptsize

\size default
] def logl(store): """function evaluates the log - likelihood for the log - linear model"""
\end_layout

\begin_layout Standard

code = """ double sum = 0.0, xbeta; for(int i=0; i<nobs; i++)
\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

 xbeta = 0.0; for(int j=0; j<kreg; j++)
\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

xbeta += xmat[i+j*kreg] * beta[j];
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 sum += yvec[i] * xbeta - exp(xbeta); 
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 returnval = sum; """ yvec = store['yvec'] xmat = store['xmat'] nobs, kreg = xmat.shape beta = store['beta'] return weave.inline(code,['yvec','xmat', 'beta','nobs','kreg'],\InsetSpace \space{}
compiler='gcc') 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

The total time taken for weave version is 4.33 seconds. The reason for the speed increase over the original version that uses 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Numpy
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 functions is the weave version avoids the construction of temporary matrices that are typically a by product of overloaded operators.
\end_layout

\begin_layout Standard

Another alternative, which is our preferred approach, is to use the 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 module 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

F2py
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

; see 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
citet{F2PY}
\end_layout

\end_inset

 for further details. 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

F2py
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 allows for the seamless integration of 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Fortran
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 and 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 code. Following on using the same trivial example we use the following 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Fortran77
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 code. This example requires that the user the have basic linear algebra subprograms (
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

BLAS
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

) and and preferable also the automatically tuned linear algebra software (
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

ATLAS
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

).
\newline
 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{lstlisting}
\end_layout

\end_inset

[basicstyle=
\size scriptsize

\size default
] c fortran 77 code used to calculate the likelihood of a log c linear model. Subroutine uses BLAS.
\end_layout

\begin_layout Standard

subroutine logl(xb,xm,bv,yv,llike,n,k) implicit none integer n, k, i, j real*8 xb(n),xm(n,k), bv(k), yv(n), llike real*8 alpha, beta
\end_layout

\begin_layout Standard

cf2py intent(in,out) logl cf2py intent(in) yv cf2py intent(ini bv cf2py intent(in) xmat cf2py intent(in) xb
\end_layout

\begin_layout Standard

alpha=1.0 beta=0.0 call dgemv('n',n,k,alpha,xm,n,bv,1,beta,xb,1)
\end_layout

\begin_layout Standard

llike=0.0 do i=1,n llike=llike+yv(i)*xb(i)-exp(xb(i)) enddo end 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

The code is compiled with the command (Note see the following subsection if you are a Microsoft Windows user, this command is for UNIX type environments such as Linux and OSX):
\end_layout

\begin_layout Standard

f2py -c loglinear.f -m loglinear -lblas -latlas
\end_layout

\begin_layout Standard

then called from 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 as follows
\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{lstlisting}
\end_layout

\end_inset

[basicstyle=
\size scriptsize

\size default
] import loglinear 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

The loglinear library must be imported to be accessible and is done as above. The log-likelihood function is then modified as follows
\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{lstlisting}
\end_layout

\end_inset

[basicstyle=
\size scriptsize

\size default
,numbers=left] def logl(store): """function evaluates the log - likelihood for the log - linear model""" loglike=array(0.0) return loglinear.logl(store['xb'],store['xmatf'], store['beta'],store['yvec'],loglike) 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

The code in example1c.py is further modified by inserting the following code before line 64 in the original program.
\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{lstlisting}
\end_layout

\end_inset

[basicstyle=
\size scriptsize

\size default
] data['xb']=zeros(yvec.shape[0]) data['xmatf']=asfortranarray(xmat) 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

The array 
\emph on
data['xb']
\emph default
 is a work array used for the calculation of 
\begin_inset Formula $\bm{X}\bm{\beta}.$
\end_inset

 It is stored in in the 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 dictionary 
\emph on
data
\emph default
, so it is only created once rather that each time the function 
\emph on
logl
\emph default
 is called. The second array 
\emph on
data['xmatf']
\emph default
 stores 
\begin_inset Formula $\bm{X}$
\end_inset

 in column major order, which is what is used in 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Fortran
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

, rather than the 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 default, which is row major order the default for the 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

C
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 programming language. If 
\emph on
store['xmat']
\emph default
 is passed to the function 
\emph on
loglinear.logl
\emph default
 then f2py will automatically produce a copy and convert it to column major order each time the function 
\emph on
logl
\emph default
 is called.
\end_layout

\begin_layout Standard

The total time for the MCMC sampler when using f2py is 4.03 seconds. This is slightly faster that the version that uses Weave, where most likely the small gain can be attributed to the use of ATLAS.
\end_layout

\begin_layout Standard

The user has many other choices available to them for writing specialised extension modules. For example, if it is the preference of the user it is not much more difficult to use 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

F2py
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 to compile procedures written in 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

C
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

, which then can be used directly from 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

. Another popular library that can be used to marry 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

C
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

, as well as 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

C++
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

, code with 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 is SWIG. In our opinion Swig is more difficult than f2py for complicated examples. The user may also opt to manually call 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

C
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 and 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

C++
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 routines using 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 and 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Numpy
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

's 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

C
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 application interface. Another option for 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

C++
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 users is to use 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Boost
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

. These alternative approaches are beyond the scope of this paper.
\end_layout

\begin_layout Subsection

Compiling Code in Windows
\end_layout

\begin_layout Standard

The previous section described how one might go about using 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 efficiently. To do this, access to a compiler is necessary. Under most flavours of UNIX, this should pose no problem, but under Microsoft Windows this can be more difficult. This section provides some brief guidelines to an approach we found workable under windows.
\end_layout

\begin_layout Standard

In order to run 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Numpy
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 and 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Scipy
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 are all required, but to have a reasonable developer experience under Windows, we suggest a few additional packages, all of which are freely available: 
\end_layout

\begin_layout Itemize

mingw (http://www.mingw.org/) which provides, among other things, the GNU compler suite. You should choose at least gcc and g++. 
\end_layout

\begin_layout Itemize

msys (http://www.mingw.org/wiki/MSYS) which provides a set of GNU utilities commonly found on Linux. This will make building and compiling code more manageable under Windows. 
\end_layout

\begin_layout Itemize

ipython (http://ipython.scipy.org/moin/), an interactive interface to 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

, which can be used as an alternative to the idle interface that is distributed with 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

. 
\end_layout

\begin_layout Itemize

pyreadline (http://ipython.scipy.org/moin/PyReadline/Intro) providing Windows readline capabilities for IPython. 
\end_layout

\begin_layout Itemize

gfortran (http://gcc.gnu.org/wiki/GFortranBinaries) provides a native Windows 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Fortran
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 compiler. 
\end_layout

\begin_layout Standard

Once these additional utilities are installed, it should be possible to compile code in different languages. To test that Weave works as expected, make sure that the mingw bin directory is in your path, and try the following code:
\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{lstlisting}
\end_layout

\end_inset

[basicstyle=
\size scriptsize

\size default
] import scipy.weave a=100 scipy.weave.inline('printf("a=
\begin_inset ERT
status collapsed

\begin_layout Standard

%d
\backslash

\backslash
n",a);',['a'],verbose=1)
\end_layout

\begin_layout Standard


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

The output should be similar to:
\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{lstlisting}
\end_layout

\end_inset

[basicstyle=
\size scriptsize

\size default
] In [4]: scipy.weave.inline('printf("a=
\begin_inset ERT
status collapsed

\begin_layout Standard

%d
\backslash

\backslash
n",a);',['a'],verbose=1)
\end_layout

\begin_layout Standard


\end_layout

\end_inset

<weave: compiling> No module named msvccompiler in numpy.distutils; trying from distutils Compiling code... Found executable c:
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
mingw
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
bin
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
g
\end_layout

\end_inset

++.exe finished compiling (sec): 2.73600006104 a=100 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

F2py
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 requires a 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Fortran
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 compiler. To set this up under Windows, follow the instructions at http://www.scipy.org/F2PY_Windows, and make sure the simple example provided works on your system. The examples presented above additionally require 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

BLAS
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 or 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

ATLAS
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 to be available. This can be built under windows (see instructions at http://www.scipy.org/Installing_SciPy/Windows, for example). To check that 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

F2py
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 and ATLAS are installed correctly, save the following code as, for example, blas_eg.f90:
\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{lstlisting}
\end_layout

\end_inset

[basicstyle=
\size scriptsize

\size default
] subroutine dgemveg() REAL*8 X(2, 3) /1.D0, 2.D0, 3.D0, 4.D0, 5.D0, 6.D0/ REAL*8 Y(3) /2.D0, 2.D0, 2.D0/ REAL*8 Z(2) CALL DGEMV('N', 2, 3, 1.D0, X, 2, Y, 1, 0.D0, Z, 1) PRINT *, Z end subroutine dgemveg 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

Set the location of your ATLAS libraries appropriately, and ensure that gfortran is in your path and compile. The following provides a template:
\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{lstlisting}
\end_layout

\end_inset

[basicstyle=
\size scriptsize

\size default
] ATLASLIBDIR="/d/tmp/pymcmcwininstall/BUILDS/lib" export PATH=
\begin_inset Formula ${PATH}:/c/Program\ Files/gfortran/libexec/gcc/i586-pc-mingw32/4.6.0:/c/Program\ Files/gfortran/bin:/c/python26 
python /c/Python26/Scripts/f2py.py -c -m foo \
   --fcompiler=gfortran \
   blas_eg.f90 -L$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

ATLASLIBDIR
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 -lf77blas -latlas -lg2c 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

This should produce a 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 dll (foo.pyd), which can be imported into 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{lstlisting}
\end_layout

\end_inset

[basicstyle=
\size scriptsize

\size default
] import foo dir(foo) print foo.doc foo.dgemveg() 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Section


\begin_inset OptArg
status collapsed


\begin_layout Standard

PyMCMC interacting with R
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 interacting with R
\end_layout

\begin_layout Standard


\begin_inset LatexCommand label
name "sec:PyMCMC-interacting-with"

\end_inset


\end_layout

\begin_layout Standard

There are a number of functions from the
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

R
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

statistical language 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
citet{R}
\end_layout

\end_inset

 that can be useful in Bayesian analysis. These can be accessed in 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 through the 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

RPy2
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 library. In 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

, we show how this can be approached prior to the Bayesian analysis, and also to explore and summarise the MCMC output. As an example, consider the Log linear model described in Section 
\begin_inset LatexCommand ref
reference "sub:Example-2:-Log-linear"

\end_inset

. The random walk MH requires the specification of a candidate density function Equation (
\begin_inset LatexCommand ref
reference "random walk candidate"

\end_inset

) and an initial value. The R functions 
\family typewriter
glm 
\family default
and 
\family typewriter
summary.glm
\family default
 can be used to set this to the maximum likelihood estimate 
\begin_inset Formula $\hat{\beta}$
\end_inset

 and the unscaled estimated covariance matrix of the estimated coefficients. The relevant code is summarised below:
\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{lstlisting}
\end_layout

\end_inset

[basicstyle=
\size scriptsize

\size default
,numbers=left,tabsize=4] import rpy2.robjects.numpy2ri from rpy2 import rinterface import rpy2.robjects as robjects ... def initialvalues(yvec,xmat): 
\begin_inset Quotes erd
\end_inset

' Use rpy2 to get the initial values 
\begin_inset Quotes erd
\end_inset

' ry = rinterface.SexpVector(yvec,rinterface.INTSXP) rx = rinterface.SexpVector(xmat[:,1:],rinterface.INTSXP) robjects.globalenv['y'] = ry robjects.globalenv['x'] = rx mod = robjects.r.glm("y\InsetSpace ~
x", family="poisson") initbeta = array(robjects.r.coefficients(mod)) modsummary = robjects.r.summary(mod) scale = array(modsummary.rx2('cov.unscaled')) return initbeta,scale
\end_layout

\begin_layout Standard

#main program random.seed(12345) #seed or the random number generator
\end_layout

\begin_layout Standard

data=loadtxt('count.txt',skiprows=1) #loads data from file yvec=data[:,0] xmat=data[:,1:data.shape[1]] xmat=hstack([ones((data.shape[0],1)),xmat])
\end_layout

\begin_layout Standard

data=
\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

'yvec':yvec,'xmat':xmat
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

#use R to obtain the initial vector for beta and the scale matrix initbeta,scale=initialvalues(yvec,xmat)
\end_layout

\begin_layout Standard

samplebeta=RWMH(posterior,scale,initbeta,'beta') GS=Gibbs(20000,4000,data, [samplebeta],loglike=(logl,xmat.shape[1],'yvec')) GS.sampler() GS.CODAoutput(filename="loglineareg")
\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

It may also be useful to take advantage of the many MCMC analysis functions in
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

R
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

and associated packages. To facilitate this, 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 includes a CODA 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
citet{Rnews:Plummer+Best+Cowles+Vines:2006}
\end_layout

\end_inset

 output format which can easily be read into
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

R
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

for further analysis. A sample R session after 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 might look like:
\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{lstlisting}
\end_layout

\end_inset

[basicstyle=
\size scriptsize

\size default
,language=R,numbers=left] library(coda) aa <- read.coda("loglineareg.txt","loglineareg.ind") plot(aa) summary(aa) raftery.diag(aa) xyplot(aa) densityplot(aa) acfplot(aa,lag.max=500)
\end_layout

\begin_layout Standard


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Section

Conclusions
\end_layout

\begin_layout Standard


\begin_inset LatexCommand label
name "sec:Conclusions"

\end_inset


\end_layout

\begin_layout Standard

In this paper, we have described the 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 software package 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

. 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 takes advantage of the flexibility and extensibility of 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Python
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 to provide the user with a code efficient way of constructing MCMC samplers. The 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 package includes classes for the MCMC sampler MH, independent MH, random walk MH, OBMC and slice sampling algorithms. It also contains an inbuilt module for Bayesian regression analysis. We demonstrate 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 using an example of Bayesian regression analysis with stochastic search variable selection, a log-linear model and also a time series regression analysis with first order autoregressive errors. We demonstrate how to optimise 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

PyMCMC
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 using 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Numpy
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 functions, inline 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

C
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 code using 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Weave
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 and with 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Fortran77
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 using 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

F2py
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

, where necessary. We further demonstrate how to call
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
proglang
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

R
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

functions using 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pkg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

RPy2
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection*

Acknowledgements
\end_layout

\begin_layout Standard

This research has been supported by an Australian Research Council Linkage Grant; LP100100565. The code was primarily developed and tested using Arch Linux http://www.archlinux.org/ and Kubuntu http://www.kubuntu.org/.
\end_layout

\begin_layout Standard


\begin_inset LatexCommand bibtex
bibfiles "chris"

\end_inset


\end_layout

\end_body
\end_document
